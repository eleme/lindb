package memdb

import "math/bits"

{{range .}}

// {{.Type}}Block represents a {{.Type}} block for storing metric point in memory
type {{.Type}}Block struct {
	// container(bit array) is a mapping from 64 value to uint64 in big-endian,
	// it is a temporary data-structure for compressing data.
	container uint64
	values    []{{.type}}
}

// new{{.Name}}Block returns {{.Type}} block with fixed time window
func new{{.Name}}Block(size uint16) *{{.Type}}Block {
	return &{{.Type}}Block{
		values: make([]{{.type}}, size),
	}
}

// getSize returns the size of values
func (b *{{.Type}}Block) getSize() uint16 {
	if b.container == 0 {
		return 0
	}
	// get trailing zeros for container
	trailing := bits.TrailingZeros64(b.container)
	return uint16(maxTimeWindow - trailing - 1)
}

// hasValue returns whether value is absent or present at pos, if present return true
func (b *{{.Type}}Block) hasValue(pos uint16) bool {
	return b.container&(1<<uint64(maxTimeWindow-pos-1)) != 0
}

// set{{.Name}}Value updates int64 value with pos
func (b *{{.Type}}Block) set{{.Name}}Value(pos uint16, value {{.type}}) {
	b.container |= 1 << uint64(maxTimeWindow-pos-1)
	b.values[pos] = value
}

// get{{.Name}}Value return int64 value for pos
func (b *{{.Type}}Block) get{{.Name}}Value(pos uint16) {{.type}} {
	return b.values[pos]
}

// memsize returns the memory size in bytes count
func (b *{{.Type}}Block) memsize() int {
	return emptyContainerSize + cap(b.values)*8
}

// reset cleans block data, just reset container mark
func (b *{{.Type}}Block) reset() {
	b.container = 0
}

func (b *{{.Type}}Block) isEmpty() bool {
	return b.container == 0
}

{{end}}