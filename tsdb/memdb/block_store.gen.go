// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: block_store.gen.go.tmpl

package memdb

import (
	"math"

	"github.com/lindb/lindb/aggregation"
	"github.com/lindb/lindb/pkg/bit"
	"github.com/lindb/lindb/pkg/encoding"
	"github.com/lindb/lindb/series/field"
)

// intBlock represents a int block for storing metric point in memory
type intBlock struct {
	container
	values []int64
}

// newIntBlock returns int block with fixed time window
func newIntBlock(size int) *intBlock {
	return &intBlock{
		values: make([]int64, size),
	}
}

// setIntValue updates int64 value with pos
func (b *intBlock) setIntValue(pos int, value int64) {
	b.setValue(pos)
	b.values[pos] = value
}

// getIntValue return int64 value for pos
func (b *intBlock) getIntValue(pos int) int64 {
	return b.values[pos]
}

// memsize returns the memory size in bytes count
func (b *intBlock) memsize() int {
	return b.container.memsize() + 24 + cap(b.values)*8
}

// compact compress block data
func (b *intBlock) compact(aggFunc field.AggFunc) (start, end int, err error) {
	hasOld := len(b.compress) > 0
	hasNew := b.container.container != 0
	var encode *encoding.TSDEncoder
	switch {
	case !hasOld && !hasNew: // no data
		return 0, 0, nil
	case !hasOld: // compact current buffer data
		end = b.getEndTime()
		start = b.startTime
		encode = encoding.NewTSDEncoder(start)
		for i := start; i <= end; i++ {
			idx := i - start
			if b.hasValue(idx) {
				encode.AppendTime(bit.One)
				encode.AppendValue(encoding.ZigZagEncode(b.values[idx]))
			} else {
				encode.AppendTime(bit.Zero)
			}
		}
	case hasOld && !hasNew: // just decode time slot range for compress data
		start, end = encoding.DecodeTSDTime(b.compress)
		return
	default: // merge current buffer data and compress data
		tsd := encoding.GetTSDDecoder()

		tsd.Reset(b.compress)
		scanner := newIntBlockMergeScanner(b, tsd)
		encode = encoding.NewTSDEncoder(scanner.start)
		scanner.mergeFunc = func(mergeType mergeType, idx int, oldValue uint64) {
			switch mergeType {
			case appendEmpty:
				encode.AppendTime(bit.Zero)
			case appendNew:
				encode.AppendTime(bit.One)
				encode.AppendValue(encoding.ZigZagEncode(b.values[idx]))
			case appendOld:
				encode.AppendTime(bit.One)
				encode.AppendValue(oldValue)
			case mergeType:
				encode.AppendTime(bit.One)
				encode.AppendValue(encoding.ZigZagEncode(aggFunc.AggregateInt(b.values[idx], encoding.ZigZagDecode(oldValue))))
			}
		}
		scanner.scan()
		encoding.ReleaseTSDDecoder(tsd)
		start = scanner.start
		end = scanner.end
	}
	// reset compress data and clear current buffer
	if encode != nil {
		data, err := encode.Bytes()
		if err != nil {
			return 0, 0, err
		}
		b.compress = data
		b.container.container = 0
	}
	return start, end, err
}

// scan scans block data, then aggregates the data
func (b *intBlock) scan(
	aggFunc field.AggFunc,
	agg []aggregation.PrimitiveAggregator,
	memScanCtx *memScanContext,
) {
	hasOld := len(b.compress) > 0
	hasNew := b.container.container != 0
	switch {
	case !hasOld && hasNew: // scans current block store buffer data
		end := b.getEndTime() - b.startTime
		for i := 0; i <= end; i++ {
			if !b.hasValue(i) {
				continue
			}
			if b.aggregate(appendNew, i, 0, aggFunc, agg) {
				return
			}
		}
	case hasOld && hasNew: // scans current buffer data and compress data, then merges them for same time slot
		tsd := memScanCtx.tsd
		tsd.Reset(b.compress)
		scanner := newIntBlockMergeScanner(b, tsd)
		scanner.mergeFunc = func(mergeType mergeType, pos int, oldValue uint64) {
			if b.aggregate(mergeType, pos, oldValue, aggFunc, agg) {
				scanner.complete = true
			}
		}
		scanner.scan()
	case hasOld: // scans compress data
		tsd := memScanCtx.tsd
		tsd.Reset(b.compress)
		for tsd.Error() == nil && tsd.Next() {
			if tsd.HasValue() {
				timeSlot := tsd.Slot()
				val := tsd.Value()
				if b.aggregate(appendOld, timeSlot, val, aggFunc, agg) {
					return
				}
			}
		}
	}
}

// aggregate aggregates the value with index
func (b *intBlock) aggregate(mergeType mergeType, idx int, oldValue uint64,
	aggFunc field.AggFunc,
	agg []aggregation.PrimitiveAggregator,
) (completed bool) {
	value := 0.0
	// 1. get value and time slot
	switch mergeType {
	case appendOld:
		value = float64(encoding.ZigZagDecode(oldValue))
	case appendNew:
		value = float64(b.values[idx])
		idx += b.startTime
	case merge:
		value = float64(aggFunc.AggregateInt(b.values[idx], encoding.ZigZagDecode(oldValue)))
		idx += b.startTime
	default:
		return
	}
	// 2. aggregate the value based on time slot
	for _, a := range agg {
		completed = a.Aggregate(idx, value)
	}
	return
}

// intBlockMergeScanner represents the scanner which scans the block store current buffer data and compress data
type intBlockMergeScanner struct {
	block            *intBlock            // current block
	tsd              *encoding.TSDDecoder // old value
	start, end       int                  // target time slot range
	curStart, curEnd int                  // current buffer time slot range
	oldStart, oldEnd int                  // compress data time slot range

	complete  bool
	mergeFunc mergeFunc
}

// newIntBlockMergeScanner creates a merge scanner
func newIntBlockMergeScanner(block *intBlock, tsd *encoding.TSDDecoder) *intBlockMergeScanner {
	scanner := &intBlockMergeScanner{
		block: block,
		tsd:   tsd,
	}
	// init scanner time slot ranges
	scanner.init()
	return scanner
}

// init initializes the scanner's time slot ranges
func (s *intBlockMergeScanner) init() {
	// start time slot
	s.curStart = s.block.startTime
	s.oldStart = s.tsd.StartTime()
	s.start = s.curStart
	if s.start > s.oldStart {
		s.start = s.oldStart
	}
	// end time slot
	s.curEnd = s.block.getEndTime()
	s.oldEnd = s.tsd.EndTime()
	s.end = s.curEnd
	if s.end < s.oldEnd {
		s.end = s.oldEnd
	}
}

// scan scans the block store current buffer data and compress data based on target time slot range
func (s *intBlockMergeScanner) scan() {
	for i := s.start; i <= s.end; i++ {
		// if scanner is completed, return it
		if s.complete {
			return
		}
		inCurrentRange := isInRange(i, s.curStart, s.curEnd)
		inOldRange := isInRange(i, s.oldStart, s.oldEnd)
		newSlot := i - s.curStart
		oldSlot := i - s.oldStart
		hasValue := s.block.hasValue(newSlot)
		hasOldValue := s.tsd.HasValueWithSlot(oldSlot)
		switch {
		case inCurrentRange && inOldRange:
			s.merge(hasValue, hasOldValue, newSlot)
		case inCurrentRange && hasValue:
			// just compress current block value with pos
			s.mergeFunc(appendNew, newSlot, 0)
		case inCurrentRange && !hasValue:
			s.mergeFunc(appendEmpty, newSlot, 0)
		case inOldRange && hasOldValue:
			// read compress data and compress it again with new pos
			s.mergeFunc(appendOld, i, s.tsd.Value())
		case inOldRange && !hasOldValue:
			s.mergeFunc(appendEmpty, i, 0)
		default:
			s.mergeFunc(appendEmpty, i, 0)
		}
	}
}

func (s *intBlockMergeScanner) merge(hasValue bool, hasOldValue bool, newSlot int) {
	// merge current block value and value in compress data with pos
	switch {
	case hasValue && hasOldValue:
		// has value both in current and old, do rollup operation with agg func
		s.mergeFunc(merge, newSlot, s.tsd.Value())
	case hasValue:
		// append current block block
		s.mergeFunc(appendNew, newSlot, 0)
	case hasOldValue:
		// read old compress value then append value with new pos
		s.mergeFunc(appendOld, newSlot, s.tsd.Value())
	default:
		// just append empty value with pos
		s.mergeFunc(appendEmpty, newSlot, 0)
	}
}

// floatBlock represents a float block for storing metric point in memory
type floatBlock struct {
	container
	values []float64
}

// newFloatBlock returns float block with fixed time window
func newFloatBlock(size int) *floatBlock {
	return &floatBlock{
		values: make([]float64, size),
	}
}

// setFloatValue updates float64 value with pos
func (b *floatBlock) setFloatValue(pos int, value float64) {
	b.setValue(pos)
	b.values[pos] = value
}

// getFloatValue return float64 value for pos
func (b *floatBlock) getFloatValue(pos int) float64 {
	return b.values[pos]
}

// memsize returns the memory size in bytes count
func (b *floatBlock) memsize() int {
	return b.container.memsize() + 24 + cap(b.values)*8
}

// compact compress block data
func (b *floatBlock) compact(aggFunc field.AggFunc) (start, end int, err error) {
	hasOld := len(b.compress) > 0
	hasNew := b.container.container != 0
	var encode *encoding.TSDEncoder
	switch {
	case !hasOld && !hasNew: // no data
		return 0, 0, nil
	case !hasOld: // compact current buffer data
		end = b.getEndTime()
		start = b.startTime
		encode = encoding.NewTSDEncoder(start)
		for i := start; i <= end; i++ {
			idx := i - start
			if b.hasValue(idx) {
				encode.AppendTime(bit.One)
				encode.AppendValue(math.Float64bits(b.values[idx]))
			} else {
				encode.AppendTime(bit.Zero)
			}
		}
	case hasOld && !hasNew: // just decode time slot range for compress data
		start, end = encoding.DecodeTSDTime(b.compress)
		return
	default: // merge current buffer data and compress data
		tsd := encoding.GetTSDDecoder()

		tsd.Reset(b.compress)
		scanner := newFloatBlockMergeScanner(b, tsd)
		encode = encoding.NewTSDEncoder(scanner.start)
		scanner.mergeFunc = func(mergeType mergeType, idx int, oldValue uint64) {
			switch mergeType {
			case appendEmpty:
				encode.AppendTime(bit.Zero)
			case appendNew:
				encode.AppendTime(bit.One)
				encode.AppendValue(math.Float64bits(b.values[idx]))
			case appendOld:
				encode.AppendTime(bit.One)
				encode.AppendValue(oldValue)
			case mergeType:
				encode.AppendTime(bit.One)
				encode.AppendValue(math.Float64bits(aggFunc.AggregateFloat(b.values[idx], math.Float64frombits(oldValue))))
			}
		}
		scanner.scan()
		encoding.ReleaseTSDDecoder(tsd)
		start = scanner.start
		end = scanner.end
	}
	// reset compress data and clear current buffer
	if encode != nil {
		data, err := encode.Bytes()
		if err != nil {
			return 0, 0, err
		}
		b.compress = data
		b.container.container = 0
	}
	return start, end, err
}

// scan scans block data, then aggregates the data
func (b *floatBlock) scan(
	aggFunc field.AggFunc,
	agg []aggregation.PrimitiveAggregator,
	memScanCtx *memScanContext,
) {
	hasOld := len(b.compress) > 0
	hasNew := b.container.container != 0
	switch {
	case !hasOld && hasNew: // scans current block store buffer data
		end := b.getEndTime() - b.startTime
		for i := 0; i <= end; i++ {
			if !b.hasValue(i) {
				continue
			}
			if b.aggregate(appendNew, i, 0, aggFunc, agg) {
				return
			}
		}
	case hasOld && hasNew: // scans current buffer data and compress data, then merges them for same time slot
		tsd := memScanCtx.tsd
		tsd.Reset(b.compress)
		scanner := newFloatBlockMergeScanner(b, tsd)
		scanner.mergeFunc = func(mergeType mergeType, pos int, oldValue uint64) {
			if b.aggregate(mergeType, pos, oldValue, aggFunc, agg) {
				scanner.complete = true
			}
		}
		scanner.scan()
	case hasOld: // scans compress data
		tsd := memScanCtx.tsd
		tsd.Reset(b.compress)
		for tsd.Error() == nil && tsd.Next() {
			if tsd.HasValue() {
				timeSlot := tsd.Slot()
				val := tsd.Value()
				if b.aggregate(appendOld, timeSlot, val, aggFunc, agg) {
					return
				}
			}
		}
	}
}

// aggregate aggregates the value with index
func (b *floatBlock) aggregate(mergeType mergeType, idx int, oldValue uint64,
	aggFunc field.AggFunc,
	agg []aggregation.PrimitiveAggregator,
) (completed bool) {
	value := 0.0
	// 1. get value and time slot
	switch mergeType {
	case appendOld:
		value = math.Float64frombits(oldValue)
	case appendNew:
		value = b.values[idx]
		idx += b.startTime
	case merge:
		value = aggFunc.AggregateFloat(b.values[idx], math.Float64frombits(oldValue))
		idx += b.startTime
	default:
		return
	}
	// 2. aggregate the value based on time slot
	for _, a := range agg {
		completed = a.Aggregate(idx, value)
	}
	return
}

// floatBlockMergeScanner represents the scanner which scans the block store current buffer data and compress data
type floatBlockMergeScanner struct {
	block            *floatBlock          // current block
	tsd              *encoding.TSDDecoder // old value
	start, end       int                  // target time slot range
	curStart, curEnd int                  // current buffer time slot range
	oldStart, oldEnd int                  // compress data time slot range

	complete  bool
	mergeFunc mergeFunc
}

// newFloatBlockMergeScanner creates a merge scanner
func newFloatBlockMergeScanner(block *floatBlock, tsd *encoding.TSDDecoder) *floatBlockMergeScanner {
	scanner := &floatBlockMergeScanner{
		block: block,
		tsd:   tsd,
	}
	// init scanner time slot ranges
	scanner.init()
	return scanner
}

// init initializes the scanner's time slot ranges
func (s *floatBlockMergeScanner) init() {
	// start time slot
	s.curStart = s.block.startTime
	s.oldStart = s.tsd.StartTime()
	s.start = s.curStart
	if s.start > s.oldStart {
		s.start = s.oldStart
	}
	// end time slot
	s.curEnd = s.block.getEndTime()
	s.oldEnd = s.tsd.EndTime()
	s.end = s.curEnd
	if s.end < s.oldEnd {
		s.end = s.oldEnd
	}
}

// scan scans the block store current buffer data and compress data based on target time slot range
func (s *floatBlockMergeScanner) scan() {
	for i := s.start; i <= s.end; i++ {
		// if scanner is completed, return it
		if s.complete {
			return
		}
		inCurrentRange := isInRange(i, s.curStart, s.curEnd)
		inOldRange := isInRange(i, s.oldStart, s.oldEnd)
		newSlot := i - s.curStart
		oldSlot := i - s.oldStart
		hasValue := s.block.hasValue(newSlot)
		hasOldValue := s.tsd.HasValueWithSlot(oldSlot)
		switch {
		case inCurrentRange && inOldRange:
			s.merge(hasValue, hasOldValue, newSlot)
		case inCurrentRange && hasValue:
			// just compress current block value with pos
			s.mergeFunc(appendNew, newSlot, 0)
		case inCurrentRange && !hasValue:
			s.mergeFunc(appendEmpty, newSlot, 0)
		case inOldRange && hasOldValue:
			// read compress data and compress it again with new pos
			s.mergeFunc(appendOld, i, s.tsd.Value())
		case inOldRange && !hasOldValue:
			s.mergeFunc(appendEmpty, i, 0)
		default:
			s.mergeFunc(appendEmpty, i, 0)
		}
	}
}

func (s *floatBlockMergeScanner) merge(hasValue bool, hasOldValue bool, newSlot int) {
	// merge current block value and value in compress data with pos
	switch {
	case hasValue && hasOldValue:
		// has value both in current and old, do rollup operation with agg func
		s.mergeFunc(merge, newSlot, s.tsd.Value())
	case hasValue:
		// append current block block
		s.mergeFunc(appendNew, newSlot, 0)
	case hasOldValue:
		// read old compress value then append value with new pos
		s.mergeFunc(appendOld, newSlot, s.tsd.Value())
	default:
		// just append empty value with pos
		s.mergeFunc(appendEmpty, newSlot, 0)
	}
}
