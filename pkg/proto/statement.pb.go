// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: statement.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Stmt struct {
	// Types that are valid to be assigned to Stmt:
	//	*Stmt_ShowDatabases
	//	*Stmt_ShowStats
	//	*Stmt_ShowMetric
	//	*Stmt_ShowFieldKeys
	//	*Stmt_ShowTagKeys
	//	*Stmt_ShowTagValues
	//	*Stmt_ShowQueries
	//	*Stmt_KillQuery
	//	*Stmt_Query
	//	*Stmt_ShowNode
	//	*Stmt_DropDatabase
	//	*Stmt_ShowInfo
	//	*Stmt_ShowTagValuesInfo
	Stmt                 isStmt_Stmt `protobuf_oneof:"stmt"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Stmt) Reset()         { *m = Stmt{} }
func (m *Stmt) String() string { return proto.CompactTextString(m) }
func (*Stmt) ProtoMessage()    {}
func (*Stmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{0}
}
func (m *Stmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stmt.Merge(m, src)
}
func (m *Stmt) XXX_Size() int {
	return m.Size()
}
func (m *Stmt) XXX_DiscardUnknown() {
	xxx_messageInfo_Stmt.DiscardUnknown(m)
}

var xxx_messageInfo_Stmt proto.InternalMessageInfo

type isStmt_Stmt interface {
	isStmt_Stmt()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Stmt_ShowDatabases struct {
	ShowDatabases *ShowDatabases `protobuf:"bytes,1,opt,name=showDatabases,proto3,oneof"`
}
type Stmt_ShowStats struct {
	ShowStats *ShowStats `protobuf:"bytes,2,opt,name=showStats,proto3,oneof"`
}
type Stmt_ShowMetric struct {
	ShowMetric *ShowMetric `protobuf:"bytes,3,opt,name=showMetric,proto3,oneof"`
}
type Stmt_ShowFieldKeys struct {
	ShowFieldKeys *ShowFieldKeys `protobuf:"bytes,4,opt,name=showFieldKeys,proto3,oneof"`
}
type Stmt_ShowTagKeys struct {
	ShowTagKeys *ShowTagKeys `protobuf:"bytes,5,opt,name=showTagKeys,proto3,oneof"`
}
type Stmt_ShowTagValues struct {
	ShowTagValues *ShowTagValues `protobuf:"bytes,6,opt,name=showTagValues,proto3,oneof"`
}
type Stmt_ShowQueries struct {
	ShowQueries *ShowQueries `protobuf:"bytes,7,opt,name=showQueries,proto3,oneof"`
}
type Stmt_KillQuery struct {
	KillQuery *KillQuery `protobuf:"bytes,8,opt,name=killQuery,proto3,oneof"`
}
type Stmt_Query struct {
	Query *Query `protobuf:"bytes,9,opt,name=query,proto3,oneof"`
}
type Stmt_ShowNode struct {
	ShowNode *ShowNode `protobuf:"bytes,11,opt,name=showNode,proto3,oneof"`
}
type Stmt_DropDatabase struct {
	DropDatabase *DropDatabase `protobuf:"bytes,13,opt,name=dropDatabase,proto3,oneof"`
}
type Stmt_ShowInfo struct {
	ShowInfo *ShowInfo `protobuf:"bytes,14,opt,name=showInfo,proto3,oneof"`
}
type Stmt_ShowTagValuesInfo struct {
	ShowTagValuesInfo *ShowTagValuesInfo `protobuf:"bytes,15,opt,name=showTagValuesInfo,proto3,oneof"`
}

func (*Stmt_ShowDatabases) isStmt_Stmt()     {}
func (*Stmt_ShowStats) isStmt_Stmt()         {}
func (*Stmt_ShowMetric) isStmt_Stmt()        {}
func (*Stmt_ShowFieldKeys) isStmt_Stmt()     {}
func (*Stmt_ShowTagKeys) isStmt_Stmt()       {}
func (*Stmt_ShowTagValues) isStmt_Stmt()     {}
func (*Stmt_ShowQueries) isStmt_Stmt()       {}
func (*Stmt_KillQuery) isStmt_Stmt()         {}
func (*Stmt_Query) isStmt_Stmt()             {}
func (*Stmt_ShowNode) isStmt_Stmt()          {}
func (*Stmt_DropDatabase) isStmt_Stmt()      {}
func (*Stmt_ShowInfo) isStmt_Stmt()          {}
func (*Stmt_ShowTagValuesInfo) isStmt_Stmt() {}

func (m *Stmt) GetStmt() isStmt_Stmt {
	if m != nil {
		return m.Stmt
	}
	return nil
}

func (m *Stmt) GetShowDatabases() *ShowDatabases {
	if x, ok := m.GetStmt().(*Stmt_ShowDatabases); ok {
		return x.ShowDatabases
	}
	return nil
}

func (m *Stmt) GetShowStats() *ShowStats {
	if x, ok := m.GetStmt().(*Stmt_ShowStats); ok {
		return x.ShowStats
	}
	return nil
}

func (m *Stmt) GetShowMetric() *ShowMetric {
	if x, ok := m.GetStmt().(*Stmt_ShowMetric); ok {
		return x.ShowMetric
	}
	return nil
}

func (m *Stmt) GetShowFieldKeys() *ShowFieldKeys {
	if x, ok := m.GetStmt().(*Stmt_ShowFieldKeys); ok {
		return x.ShowFieldKeys
	}
	return nil
}

func (m *Stmt) GetShowTagKeys() *ShowTagKeys {
	if x, ok := m.GetStmt().(*Stmt_ShowTagKeys); ok {
		return x.ShowTagKeys
	}
	return nil
}

func (m *Stmt) GetShowTagValues() *ShowTagValues {
	if x, ok := m.GetStmt().(*Stmt_ShowTagValues); ok {
		return x.ShowTagValues
	}
	return nil
}

func (m *Stmt) GetShowQueries() *ShowQueries {
	if x, ok := m.GetStmt().(*Stmt_ShowQueries); ok {
		return x.ShowQueries
	}
	return nil
}

func (m *Stmt) GetKillQuery() *KillQuery {
	if x, ok := m.GetStmt().(*Stmt_KillQuery); ok {
		return x.KillQuery
	}
	return nil
}

func (m *Stmt) GetQuery() *Query {
	if x, ok := m.GetStmt().(*Stmt_Query); ok {
		return x.Query
	}
	return nil
}

func (m *Stmt) GetShowNode() *ShowNode {
	if x, ok := m.GetStmt().(*Stmt_ShowNode); ok {
		return x.ShowNode
	}
	return nil
}

func (m *Stmt) GetDropDatabase() *DropDatabase {
	if x, ok := m.GetStmt().(*Stmt_DropDatabase); ok {
		return x.DropDatabase
	}
	return nil
}

func (m *Stmt) GetShowInfo() *ShowInfo {
	if x, ok := m.GetStmt().(*Stmt_ShowInfo); ok {
		return x.ShowInfo
	}
	return nil
}

func (m *Stmt) GetShowTagValuesInfo() *ShowTagValuesInfo {
	if x, ok := m.GetStmt().(*Stmt_ShowTagValuesInfo); ok {
		return x.ShowTagValuesInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Stmt) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Stmt_OneofMarshaler, _Stmt_OneofUnmarshaler, _Stmt_OneofSizer, []interface{}{
		(*Stmt_ShowDatabases)(nil),
		(*Stmt_ShowStats)(nil),
		(*Stmt_ShowMetric)(nil),
		(*Stmt_ShowFieldKeys)(nil),
		(*Stmt_ShowTagKeys)(nil),
		(*Stmt_ShowTagValues)(nil),
		(*Stmt_ShowQueries)(nil),
		(*Stmt_KillQuery)(nil),
		(*Stmt_Query)(nil),
		(*Stmt_ShowNode)(nil),
		(*Stmt_DropDatabase)(nil),
		(*Stmt_ShowInfo)(nil),
		(*Stmt_ShowTagValuesInfo)(nil),
	}
}

func _Stmt_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Stmt)
	// stmt
	switch x := m.Stmt.(type) {
	case *Stmt_ShowDatabases:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowDatabases); err != nil {
			return err
		}
	case *Stmt_ShowStats:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowStats); err != nil {
			return err
		}
	case *Stmt_ShowMetric:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowMetric); err != nil {
			return err
		}
	case *Stmt_ShowFieldKeys:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowFieldKeys); err != nil {
			return err
		}
	case *Stmt_ShowTagKeys:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowTagKeys); err != nil {
			return err
		}
	case *Stmt_ShowTagValues:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowTagValues); err != nil {
			return err
		}
	case *Stmt_ShowQueries:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowQueries); err != nil {
			return err
		}
	case *Stmt_KillQuery:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KillQuery); err != nil {
			return err
		}
	case *Stmt_Query:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Query); err != nil {
			return err
		}
	case *Stmt_ShowNode:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowNode); err != nil {
			return err
		}
	case *Stmt_DropDatabase:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DropDatabase); err != nil {
			return err
		}
	case *Stmt_ShowInfo:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowInfo); err != nil {
			return err
		}
	case *Stmt_ShowTagValuesInfo:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowTagValuesInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Stmt.Stmt has unexpected type %T", x)
	}
	return nil
}

func _Stmt_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Stmt)
	switch tag {
	case 1: // stmt.showDatabases
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowDatabases)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowDatabases{msg}
		return true, err
	case 2: // stmt.showStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowStats)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowStats{msg}
		return true, err
	case 3: // stmt.showMetric
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowMetric)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowMetric{msg}
		return true, err
	case 4: // stmt.showFieldKeys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowFieldKeys)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowFieldKeys{msg}
		return true, err
	case 5: // stmt.showTagKeys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowTagKeys)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowTagKeys{msg}
		return true, err
	case 6: // stmt.showTagValues
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowTagValues)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowTagValues{msg}
		return true, err
	case 7: // stmt.showQueries
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowQueries)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowQueries{msg}
		return true, err
	case 8: // stmt.killQuery
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KillQuery)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_KillQuery{msg}
		return true, err
	case 9: // stmt.query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Query)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_Query{msg}
		return true, err
	case 11: // stmt.showNode
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowNode)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowNode{msg}
		return true, err
	case 13: // stmt.dropDatabase
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DropDatabase)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_DropDatabase{msg}
		return true, err
	case 14: // stmt.showInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowInfo)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowInfo{msg}
		return true, err
	case 15: // stmt.showTagValuesInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowTagValuesInfo)
		err := b.DecodeMessage(msg)
		m.Stmt = &Stmt_ShowTagValuesInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Stmt_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Stmt)
	// stmt
	switch x := m.Stmt.(type) {
	case *Stmt_ShowDatabases:
		s := proto.Size(x.ShowDatabases)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowStats:
		s := proto.Size(x.ShowStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowMetric:
		s := proto.Size(x.ShowMetric)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowFieldKeys:
		s := proto.Size(x.ShowFieldKeys)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowTagKeys:
		s := proto.Size(x.ShowTagKeys)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowTagValues:
		s := proto.Size(x.ShowTagValues)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowQueries:
		s := proto.Size(x.ShowQueries)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_KillQuery:
		s := proto.Size(x.KillQuery)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_Query:
		s := proto.Size(x.Query)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowNode:
		s := proto.Size(x.ShowNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_DropDatabase:
		s := proto.Size(x.DropDatabase)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowInfo:
		s := proto.Size(x.ShowInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Stmt_ShowTagValuesInfo:
		s := proto.Size(x.ShowTagValuesInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ResultSet struct {
	// Types that are valid to be assigned to Result:
	//	*ResultSet_ShowDatabases
	//	*ResultSet_ShowStats
	//	*ResultSet_ShowMetric
	//	*ResultSet_ShowTagKeys
	//	*ResultSet_ShowTagValues
	//	*ResultSet_ShowFieldKeys
	//	*ResultSet_Query
	//	*ResultSet_ShowNode
	//	*ResultSet_ShowInfo
	//	*ResultSet_ShowTagValuesInfo
	Result               isResultSet_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ResultSet) Reset()         { *m = ResultSet{} }
func (m *ResultSet) String() string { return proto.CompactTextString(m) }
func (*ResultSet) ProtoMessage()    {}
func (*ResultSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{1}
}
func (m *ResultSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultSet.Merge(m, src)
}
func (m *ResultSet) XXX_Size() int {
	return m.Size()
}
func (m *ResultSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultSet.DiscardUnknown(m)
}

var xxx_messageInfo_ResultSet proto.InternalMessageInfo

type isResultSet_Result interface {
	isResultSet_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResultSet_ShowDatabases struct {
	ShowDatabases *ShowDatabasesResult `protobuf:"bytes,1,opt,name=showDatabases,proto3,oneof"`
}
type ResultSet_ShowStats struct {
	ShowStats *ShowStatsResult `protobuf:"bytes,2,opt,name=showStats,proto3,oneof"`
}
type ResultSet_ShowMetric struct {
	ShowMetric *ShowMetricResult `protobuf:"bytes,3,opt,name=showMetric,proto3,oneof"`
}
type ResultSet_ShowTagKeys struct {
	ShowTagKeys *ShowTagKeysResult `protobuf:"bytes,4,opt,name=showTagKeys,proto3,oneof"`
}
type ResultSet_ShowTagValues struct {
	ShowTagValues *ShowTagValuesResult `protobuf:"bytes,5,opt,name=showTagValues,proto3,oneof"`
}
type ResultSet_ShowFieldKeys struct {
	ShowFieldKeys *ShowFieldKeysResult `protobuf:"bytes,6,opt,name=showFieldKeys,proto3,oneof"`
}
type ResultSet_Query struct {
	Query *QueryResult `protobuf:"bytes,7,opt,name=query,proto3,oneof"`
}
type ResultSet_ShowNode struct {
	ShowNode *ShowNodeResult `protobuf:"bytes,8,opt,name=showNode,proto3,oneof"`
}
type ResultSet_ShowInfo struct {
	ShowInfo *ShowInfoResult `protobuf:"bytes,9,opt,name=showInfo,proto3,oneof"`
}
type ResultSet_ShowTagValuesInfo struct {
	ShowTagValuesInfo *ShowTagValuesInfoResult `protobuf:"bytes,10,opt,name=showTagValuesInfo,proto3,oneof"`
}

func (*ResultSet_ShowDatabases) isResultSet_Result()     {}
func (*ResultSet_ShowStats) isResultSet_Result()         {}
func (*ResultSet_ShowMetric) isResultSet_Result()        {}
func (*ResultSet_ShowTagKeys) isResultSet_Result()       {}
func (*ResultSet_ShowTagValues) isResultSet_Result()     {}
func (*ResultSet_ShowFieldKeys) isResultSet_Result()     {}
func (*ResultSet_Query) isResultSet_Result()             {}
func (*ResultSet_ShowNode) isResultSet_Result()          {}
func (*ResultSet_ShowInfo) isResultSet_Result()          {}
func (*ResultSet_ShowTagValuesInfo) isResultSet_Result() {}

func (m *ResultSet) GetResult() isResultSet_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ResultSet) GetShowDatabases() *ShowDatabasesResult {
	if x, ok := m.GetResult().(*ResultSet_ShowDatabases); ok {
		return x.ShowDatabases
	}
	return nil
}

func (m *ResultSet) GetShowStats() *ShowStatsResult {
	if x, ok := m.GetResult().(*ResultSet_ShowStats); ok {
		return x.ShowStats
	}
	return nil
}

func (m *ResultSet) GetShowMetric() *ShowMetricResult {
	if x, ok := m.GetResult().(*ResultSet_ShowMetric); ok {
		return x.ShowMetric
	}
	return nil
}

func (m *ResultSet) GetShowTagKeys() *ShowTagKeysResult {
	if x, ok := m.GetResult().(*ResultSet_ShowTagKeys); ok {
		return x.ShowTagKeys
	}
	return nil
}

func (m *ResultSet) GetShowTagValues() *ShowTagValuesResult {
	if x, ok := m.GetResult().(*ResultSet_ShowTagValues); ok {
		return x.ShowTagValues
	}
	return nil
}

func (m *ResultSet) GetShowFieldKeys() *ShowFieldKeysResult {
	if x, ok := m.GetResult().(*ResultSet_ShowFieldKeys); ok {
		return x.ShowFieldKeys
	}
	return nil
}

func (m *ResultSet) GetQuery() *QueryResult {
	if x, ok := m.GetResult().(*ResultSet_Query); ok {
		return x.Query
	}
	return nil
}

func (m *ResultSet) GetShowNode() *ShowNodeResult {
	if x, ok := m.GetResult().(*ResultSet_ShowNode); ok {
		return x.ShowNode
	}
	return nil
}

func (m *ResultSet) GetShowInfo() *ShowInfoResult {
	if x, ok := m.GetResult().(*ResultSet_ShowInfo); ok {
		return x.ShowInfo
	}
	return nil
}

func (m *ResultSet) GetShowTagValuesInfo() *ShowTagValuesInfoResult {
	if x, ok := m.GetResult().(*ResultSet_ShowTagValuesInfo); ok {
		return x.ShowTagValuesInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResultSet) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResultSet_OneofMarshaler, _ResultSet_OneofUnmarshaler, _ResultSet_OneofSizer, []interface{}{
		(*ResultSet_ShowDatabases)(nil),
		(*ResultSet_ShowStats)(nil),
		(*ResultSet_ShowMetric)(nil),
		(*ResultSet_ShowTagKeys)(nil),
		(*ResultSet_ShowTagValues)(nil),
		(*ResultSet_ShowFieldKeys)(nil),
		(*ResultSet_Query)(nil),
		(*ResultSet_ShowNode)(nil),
		(*ResultSet_ShowInfo)(nil),
		(*ResultSet_ShowTagValuesInfo)(nil),
	}
}

func _ResultSet_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResultSet)
	// result
	switch x := m.Result.(type) {
	case *ResultSet_ShowDatabases:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowDatabases); err != nil {
			return err
		}
	case *ResultSet_ShowStats:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowStats); err != nil {
			return err
		}
	case *ResultSet_ShowMetric:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowMetric); err != nil {
			return err
		}
	case *ResultSet_ShowTagKeys:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowTagKeys); err != nil {
			return err
		}
	case *ResultSet_ShowTagValues:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowTagValues); err != nil {
			return err
		}
	case *ResultSet_ShowFieldKeys:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowFieldKeys); err != nil {
			return err
		}
	case *ResultSet_Query:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Query); err != nil {
			return err
		}
	case *ResultSet_ShowNode:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowNode); err != nil {
			return err
		}
	case *ResultSet_ShowInfo:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowInfo); err != nil {
			return err
		}
	case *ResultSet_ShowTagValuesInfo:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ShowTagValuesInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResultSet.Result has unexpected type %T", x)
	}
	return nil
}

func _ResultSet_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResultSet)
	switch tag {
	case 1: // result.showDatabases
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowDatabasesResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowDatabases{msg}
		return true, err
	case 2: // result.showStats
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowStatsResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowStats{msg}
		return true, err
	case 3: // result.showMetric
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowMetricResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowMetric{msg}
		return true, err
	case 4: // result.showTagKeys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowTagKeysResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowTagKeys{msg}
		return true, err
	case 5: // result.showTagValues
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowTagValuesResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowTagValues{msg}
		return true, err
	case 6: // result.showFieldKeys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowFieldKeysResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowFieldKeys{msg}
		return true, err
	case 7: // result.query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QueryResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_Query{msg}
		return true, err
	case 8: // result.showNode
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowNodeResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowNode{msg}
		return true, err
	case 9: // result.showInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowInfoResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowInfo{msg}
		return true, err
	case 10: // result.showTagValuesInfo
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ShowTagValuesInfoResult)
		err := b.DecodeMessage(msg)
		m.Result = &ResultSet_ShowTagValuesInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResultSet_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResultSet)
	// result
	switch x := m.Result.(type) {
	case *ResultSet_ShowDatabases:
		s := proto.Size(x.ShowDatabases)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowStats:
		s := proto.Size(x.ShowStats)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowMetric:
		s := proto.Size(x.ShowMetric)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowTagKeys:
		s := proto.Size(x.ShowTagKeys)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowTagValues:
		s := proto.Size(x.ShowTagValues)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowFieldKeys:
		s := proto.Size(x.ShowFieldKeys)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_Query:
		s := proto.Size(x.Query)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowNode:
		s := proto.Size(x.ShowNode)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowInfo:
		s := proto.Size(x.ShowInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResultSet_ShowTagValuesInfo:
		s := proto.Size(x.ShowTagValuesInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DropDatabase struct {
	Database             string   `protobuf:"bytes,1,opt,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropDatabase) Reset()         { *m = DropDatabase{} }
func (m *DropDatabase) String() string { return proto.CompactTextString(m) }
func (*DropDatabase) ProtoMessage()    {}
func (*DropDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{2}
}
func (m *DropDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropDatabase.Merge(m, src)
}
func (m *DropDatabase) XXX_Size() int {
	return m.Size()
}
func (m *DropDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_DropDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_DropDatabase proto.InternalMessageInfo

func (m *DropDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

type ShowDatabases struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowDatabases) Reset()         { *m = ShowDatabases{} }
func (m *ShowDatabases) String() string { return proto.CompactTextString(m) }
func (*ShowDatabases) ProtoMessage()    {}
func (*ShowDatabases) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{3}
}
func (m *ShowDatabases) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDatabases) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDatabases.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowDatabases) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDatabases.Merge(m, src)
}
func (m *ShowDatabases) XXX_Size() int {
	return m.Size()
}
func (m *ShowDatabases) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDatabases.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDatabases proto.InternalMessageInfo

type ShowNode struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowNode) Reset()         { *m = ShowNode{} }
func (m *ShowNode) String() string { return proto.CompactTextString(m) }
func (*ShowNode) ProtoMessage()    {}
func (*ShowNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{4}
}
func (m *ShowNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowNode.Merge(m, src)
}
func (m *ShowNode) XXX_Size() int {
	return m.Size()
}
func (m *ShowNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowNode.DiscardUnknown(m)
}

var xxx_messageInfo_ShowNode proto.InternalMessageInfo

type ShowNodeResult struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowNodeResult) Reset()         { *m = ShowNodeResult{} }
func (m *ShowNodeResult) String() string { return proto.CompactTextString(m) }
func (*ShowNodeResult) ProtoMessage()    {}
func (*ShowNodeResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{5}
}
func (m *ShowNodeResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowNodeResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowNodeResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowNodeResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowNodeResult.Merge(m, src)
}
func (m *ShowNodeResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowNodeResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowNodeResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowNodeResult proto.InternalMessageInfo

type ShowDatabasesResult struct {
	Database             []string `protobuf:"bytes,1,rep,name=database,proto3" json:"database,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowDatabasesResult) Reset()         { *m = ShowDatabasesResult{} }
func (m *ShowDatabasesResult) String() string { return proto.CompactTextString(m) }
func (*ShowDatabasesResult) ProtoMessage()    {}
func (*ShowDatabasesResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{6}
}
func (m *ShowDatabasesResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDatabasesResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDatabasesResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowDatabasesResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDatabasesResult.Merge(m, src)
}
func (m *ShowDatabasesResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowDatabasesResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDatabasesResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDatabasesResult proto.InternalMessageInfo

func (m *ShowDatabasesResult) GetDatabase() []string {
	if m != nil {
		return m.Database
	}
	return nil
}

type ShowStats struct {
	Module               string   `protobuf:"bytes,1,opt,name=module,proto3" json:"module,omitempty"`
	Component            string   `protobuf:"bytes,2,opt,name=component,proto3" json:"component,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowStats) Reset()         { *m = ShowStats{} }
func (m *ShowStats) String() string { return proto.CompactTextString(m) }
func (*ShowStats) ProtoMessage()    {}
func (*ShowStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{7}
}
func (m *ShowStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowStats.Merge(m, src)
}
func (m *ShowStats) XXX_Size() int {
	return m.Size()
}
func (m *ShowStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowStats.DiscardUnknown(m)
}

var xxx_messageInfo_ShowStats proto.InternalMessageInfo

func (m *ShowStats) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *ShowStats) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

type ShowStatsResult struct {
	//    Master master = 1;
	DatabaseStates []*DatabaseState `protobuf:"bytes,3,rep,name=databaseStates,proto3" json:"databaseStates,omitempty"`
	//    repeated ShardState shardState = 4;
	ShardForNodeState    []*ShardForNode `protobuf:"bytes,5,rep,name=shardForNodeState,proto3" json:"shardForNodeState,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ShowStatsResult) Reset()         { *m = ShowStatsResult{} }
func (m *ShowStatsResult) String() string { return proto.CompactTextString(m) }
func (*ShowStatsResult) ProtoMessage()    {}
func (*ShowStatsResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{8}
}
func (m *ShowStatsResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowStatsResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowStatsResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowStatsResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowStatsResult.Merge(m, src)
}
func (m *ShowStatsResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowStatsResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowStatsResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowStatsResult proto.InternalMessageInfo

func (m *ShowStatsResult) GetDatabaseStates() []*DatabaseState {
	if m != nil {
		return m.DatabaseStates
	}
	return nil
}

func (m *ShowStatsResult) GetShardForNodeState() []*ShardForNode {
	if m != nil {
		return m.ShardForNodeState
	}
	return nil
}

type ShowMetric struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Limit                int32    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowMetric) Reset()         { *m = ShowMetric{} }
func (m *ShowMetric) String() string { return proto.CompactTextString(m) }
func (*ShowMetric) ProtoMessage()    {}
func (*ShowMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{9}
}
func (m *ShowMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowMetric.Merge(m, src)
}
func (m *ShowMetric) XXX_Size() int {
	return m.Size()
}
func (m *ShowMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowMetric.DiscardUnknown(m)
}

var xxx_messageInfo_ShowMetric proto.InternalMessageInfo

func (m *ShowMetric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ShowMetric) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ShowMetricResult struct {
	Name                 []string `protobuf:"bytes,1,rep,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowMetricResult) Reset()         { *m = ShowMetricResult{} }
func (m *ShowMetricResult) String() string { return proto.CompactTextString(m) }
func (*ShowMetricResult) ProtoMessage()    {}
func (*ShowMetricResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{10}
}
func (m *ShowMetricResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowMetricResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowMetricResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowMetricResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowMetricResult.Merge(m, src)
}
func (m *ShowMetricResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowMetricResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowMetricResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowMetricResult proto.InternalMessageInfo

func (m *ShowMetricResult) GetName() []string {
	if m != nil {
		return m.Name
	}
	return nil
}

type ShowFieldKeys struct {
	Measurement          string   `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	Limit                int32    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowFieldKeys) Reset()         { *m = ShowFieldKeys{} }
func (m *ShowFieldKeys) String() string { return proto.CompactTextString(m) }
func (*ShowFieldKeys) ProtoMessage()    {}
func (*ShowFieldKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{11}
}
func (m *ShowFieldKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowFieldKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowFieldKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowFieldKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowFieldKeys.Merge(m, src)
}
func (m *ShowFieldKeys) XXX_Size() int {
	return m.Size()
}
func (m *ShowFieldKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowFieldKeys.DiscardUnknown(m)
}

var xxx_messageInfo_ShowFieldKeys proto.InternalMessageInfo

func (m *ShowFieldKeys) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowFieldKeys) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ShowFieldKeysResult struct {
	Measurement          string            `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	Fields               map[string]string `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ShowFieldKeysResult) Reset()         { *m = ShowFieldKeysResult{} }
func (m *ShowFieldKeysResult) String() string { return proto.CompactTextString(m) }
func (*ShowFieldKeysResult) ProtoMessage()    {}
func (*ShowFieldKeysResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{12}
}
func (m *ShowFieldKeysResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowFieldKeysResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowFieldKeysResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowFieldKeysResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowFieldKeysResult.Merge(m, src)
}
func (m *ShowFieldKeysResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowFieldKeysResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowFieldKeysResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowFieldKeysResult proto.InternalMessageInfo

func (m *ShowFieldKeysResult) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowFieldKeysResult) GetFields() map[string]string {
	if m != nil {
		return m.Fields
	}
	return nil
}

type ShowInfoResult struct {
	Measurement          string            `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	Node                 string            `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	Info                 map[string]string `protobuf:"bytes,3,rep,name=info,proto3" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ShowInfoResult) Reset()         { *m = ShowInfoResult{} }
func (m *ShowInfoResult) String() string { return proto.CompactTextString(m) }
func (*ShowInfoResult) ProtoMessage()    {}
func (*ShowInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{13}
}
func (m *ShowInfoResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowInfoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowInfoResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowInfoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowInfoResult.Merge(m, src)
}
func (m *ShowInfoResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowInfoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowInfoResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowInfoResult proto.InternalMessageInfo

func (m *ShowInfoResult) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowInfoResult) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *ShowInfoResult) GetInfo() map[string]string {
	if m != nil {
		return m.Info
	}
	return nil
}

type ShowTagKeys struct {
	Measurement          string   `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	Limit                int32    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowTagKeys) Reset()         { *m = ShowTagKeys{} }
func (m *ShowTagKeys) String() string { return proto.CompactTextString(m) }
func (*ShowTagKeys) ProtoMessage()    {}
func (*ShowTagKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{14}
}
func (m *ShowTagKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowTagKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowTagKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowTagKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowTagKeys.Merge(m, src)
}
func (m *ShowTagKeys) XXX_Size() int {
	return m.Size()
}
func (m *ShowTagKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowTagKeys.DiscardUnknown(m)
}

var xxx_messageInfo_ShowTagKeys proto.InternalMessageInfo

func (m *ShowTagKeys) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowTagKeys) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ShowInfo struct {
	Measurement          string   `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowInfo) Reset()         { *m = ShowInfo{} }
func (m *ShowInfo) String() string { return proto.CompactTextString(m) }
func (*ShowInfo) ProtoMessage()    {}
func (*ShowInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{15}
}
func (m *ShowInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowInfo.Merge(m, src)
}
func (m *ShowInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShowInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShowInfo proto.InternalMessageInfo

func (m *ShowInfo) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

type ShowTagKeysResult struct {
	Measurement          string   `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	TagKeys              []string `protobuf:"bytes,2,rep,name=tagKeys,proto3" json:"tagKeys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowTagKeysResult) Reset()         { *m = ShowTagKeysResult{} }
func (m *ShowTagKeysResult) String() string { return proto.CompactTextString(m) }
func (*ShowTagKeysResult) ProtoMessage()    {}
func (*ShowTagKeysResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{16}
}
func (m *ShowTagKeysResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowTagKeysResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowTagKeysResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowTagKeysResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowTagKeysResult.Merge(m, src)
}
func (m *ShowTagKeysResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowTagKeysResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowTagKeysResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowTagKeysResult proto.InternalMessageInfo

func (m *ShowTagKeysResult) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowTagKeysResult) GetTagKeys() []string {
	if m != nil {
		return m.TagKeys
	}
	return nil
}

type ShowTagValues struct {
	Measurement          string     `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	TagKey               string     `protobuf:"bytes,2,opt,name=tagKey,proto3" json:"tagKey,omitempty"`
	TagValue             string     `protobuf:"bytes,3,opt,name=tagValue,proto3" json:"tagValue,omitempty"`
	Limit                int32      `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	Condition            *Condition `protobuf:"bytes,5,opt,name=condition,proto3" json:"condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ShowTagValues) Reset()         { *m = ShowTagValues{} }
func (m *ShowTagValues) String() string { return proto.CompactTextString(m) }
func (*ShowTagValues) ProtoMessage()    {}
func (*ShowTagValues) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{17}
}
func (m *ShowTagValues) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowTagValues) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowTagValues.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowTagValues) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowTagValues.Merge(m, src)
}
func (m *ShowTagValues) XXX_Size() int {
	return m.Size()
}
func (m *ShowTagValues) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowTagValues.DiscardUnknown(m)
}

var xxx_messageInfo_ShowTagValues proto.InternalMessageInfo

func (m *ShowTagValues) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowTagValues) GetTagKey() string {
	if m != nil {
		return m.TagKey
	}
	return ""
}

func (m *ShowTagValues) GetTagValue() string {
	if m != nil {
		return m.TagValue
	}
	return ""
}

func (m *ShowTagValues) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ShowTagValues) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

type ShowTagValuesResult struct {
	Measurement          string   `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Values               []string `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowTagValuesResult) Reset()         { *m = ShowTagValuesResult{} }
func (m *ShowTagValuesResult) String() string { return proto.CompactTextString(m) }
func (*ShowTagValuesResult) ProtoMessage()    {}
func (*ShowTagValuesResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{18}
}
func (m *ShowTagValuesResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowTagValuesResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowTagValuesResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowTagValuesResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowTagValuesResult.Merge(m, src)
}
func (m *ShowTagValuesResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowTagValuesResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowTagValuesResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowTagValuesResult proto.InternalMessageInfo

func (m *ShowTagValuesResult) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowTagValuesResult) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *ShowTagValuesResult) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type ShowTagValuesInfo struct {
	Measurement          string   `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	TagKey               string   `protobuf:"bytes,2,opt,name=tagKey,proto3" json:"tagKey,omitempty"`
	TagValue             string   `protobuf:"bytes,3,opt,name=tagValue,proto3" json:"tagValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowTagValuesInfo) Reset()         { *m = ShowTagValuesInfo{} }
func (m *ShowTagValuesInfo) String() string { return proto.CompactTextString(m) }
func (*ShowTagValuesInfo) ProtoMessage()    {}
func (*ShowTagValuesInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{19}
}
func (m *ShowTagValuesInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowTagValuesInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowTagValuesInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowTagValuesInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowTagValuesInfo.Merge(m, src)
}
func (m *ShowTagValuesInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShowTagValuesInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowTagValuesInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShowTagValuesInfo proto.InternalMessageInfo

func (m *ShowTagValuesInfo) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowTagValuesInfo) GetTagKey() string {
	if m != nil {
		return m.TagKey
	}
	return ""
}

func (m *ShowTagValuesInfo) GetTagValue() string {
	if m != nil {
		return m.TagValue
	}
	return ""
}

type ShowTagValuesInfoResult struct {
	Measurement          string            `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	TagKey               string            `protobuf:"bytes,2,opt,name=tagKey,proto3" json:"tagKey,omitempty"`
	TagValue             string            `protobuf:"bytes,3,opt,name=tagValue,proto3" json:"tagValue,omitempty"`
	Node                 string            `protobuf:"bytes,4,opt,name=node,proto3" json:"node,omitempty"`
	Info                 map[string]string `protobuf:"bytes,5,rep,name=info,proto3" json:"info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ShowTagValuesInfoResult) Reset()         { *m = ShowTagValuesInfoResult{} }
func (m *ShowTagValuesInfoResult) String() string { return proto.CompactTextString(m) }
func (*ShowTagValuesInfoResult) ProtoMessage()    {}
func (*ShowTagValuesInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{20}
}
func (m *ShowTagValuesInfoResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowTagValuesInfoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowTagValuesInfoResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowTagValuesInfoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowTagValuesInfoResult.Merge(m, src)
}
func (m *ShowTagValuesInfoResult) XXX_Size() int {
	return m.Size()
}
func (m *ShowTagValuesInfoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowTagValuesInfoResult.DiscardUnknown(m)
}

var xxx_messageInfo_ShowTagValuesInfoResult proto.InternalMessageInfo

func (m *ShowTagValuesInfoResult) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *ShowTagValuesInfoResult) GetTagKey() string {
	if m != nil {
		return m.TagKey
	}
	return ""
}

func (m *ShowTagValuesInfoResult) GetTagValue() string {
	if m != nil {
		return m.TagValue
	}
	return ""
}

func (m *ShowTagValuesInfoResult) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *ShowTagValuesInfoResult) GetInfo() map[string]string {
	if m != nil {
		return m.Info
	}
	return nil
}

type ShowQueries struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowQueries) Reset()         { *m = ShowQueries{} }
func (m *ShowQueries) String() string { return proto.CompactTextString(m) }
func (*ShowQueries) ProtoMessage()    {}
func (*ShowQueries) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{21}
}
func (m *ShowQueries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowQueries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowQueries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowQueries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowQueries.Merge(m, src)
}
func (m *ShowQueries) XXX_Size() int {
	return m.Size()
}
func (m *ShowQueries) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowQueries.DiscardUnknown(m)
}

var xxx_messageInfo_ShowQueries proto.InternalMessageInfo

type KillQuery struct {
	QueryId              int64    `protobuf:"varint,1,opt,name=queryId,proto3" json:"queryId,omitempty"`
	ServerId             int32    `protobuf:"varint,2,opt,name=serverId,proto3" json:"serverId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KillQuery) Reset()         { *m = KillQuery{} }
func (m *KillQuery) String() string { return proto.CompactTextString(m) }
func (*KillQuery) ProtoMessage()    {}
func (*KillQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{22}
}
func (m *KillQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KillQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KillQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KillQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KillQuery.Merge(m, src)
}
func (m *KillQuery) XXX_Size() int {
	return m.Size()
}
func (m *KillQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_KillQuery.DiscardUnknown(m)
}

var xxx_messageInfo_KillQuery proto.InternalMessageInfo

func (m *KillQuery) GetQueryId() int64 {
	if m != nil {
		return m.QueryId
	}
	return 0
}

func (m *KillQuery) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

type Query struct {
	Measurement          string                 `protobuf:"bytes,1,opt,name=measurement,proto3" json:"measurement,omitempty"`
	TimeRange            *TimeRange             `protobuf:"bytes,2,opt,name=timeRange,proto3" json:"timeRange,omitempty"`
	Interval             int64                  `protobuf:"varint,3,opt,name=interval,proto3" json:"interval,omitempty"`
	FieldExprList        []*FieldExpr           `protobuf:"bytes,4,rep,name=fieldExprList,proto3" json:"fieldExprList,omitempty"`
	ConditionAggregators []*ConditionAggregator `protobuf:"bytes,5,rep,name=conditionAggregators,proto3" json:"conditionAggregators,omitempty"`
	Condition            *Condition             `protobuf:"bytes,6,opt,name=condition,proto3" json:"condition,omitempty"`
	OrderBy              *OrderByExpr           `protobuf:"bytes,7,opt,name=orderBy,proto3" json:"orderBy,omitempty"`
	GroupByExpr          *GroupByExpr           `protobuf:"bytes,8,opt,name=groupByExpr,proto3" json:"groupByExpr,omitempty"`
	Limit                int32                  `protobuf:"varint,9,opt,name=limit,proto3" json:"limit,omitempty"`
	IntervalBy           string                 `protobuf:"bytes,10,opt,name=intervalBy,proto3" json:"intervalBy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{23}
}
func (m *Query) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Query.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return m.Size()
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetMeasurement() string {
	if m != nil {
		return m.Measurement
	}
	return ""
}

func (m *Query) GetTimeRange() *TimeRange {
	if m != nil {
		return m.TimeRange
	}
	return nil
}

func (m *Query) GetInterval() int64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *Query) GetFieldExprList() []*FieldExpr {
	if m != nil {
		return m.FieldExprList
	}
	return nil
}

func (m *Query) GetConditionAggregators() []*ConditionAggregator {
	if m != nil {
		return m.ConditionAggregators
	}
	return nil
}

func (m *Query) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *Query) GetOrderBy() *OrderByExpr {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *Query) GetGroupByExpr() *GroupByExpr {
	if m != nil {
		return m.GroupByExpr
	}
	return nil
}

func (m *Query) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Query) GetIntervalBy() string {
	if m != nil {
		return m.IntervalBy
	}
	return ""
}

type ConditionAggregator struct {
	Condition            *Condition `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	UnitId               int32      `protobuf:"varint,2,opt,name=unitId,proto3" json:"unitId,omitempty"`
	Field                string     `protobuf:"bytes,3,opt,name=field,proto3" json:"field,omitempty"`
	DownSampling         string     `protobuf:"bytes,4,opt,name=downSampling,proto3" json:"downSampling,omitempty"`
	Aggregator           string     `protobuf:"bytes,5,opt,name=aggregator,proto3" json:"aggregator,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ConditionAggregator) Reset()         { *m = ConditionAggregator{} }
func (m *ConditionAggregator) String() string { return proto.CompactTextString(m) }
func (*ConditionAggregator) ProtoMessage()    {}
func (*ConditionAggregator) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{24}
}
func (m *ConditionAggregator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionAggregator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionAggregator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionAggregator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionAggregator.Merge(m, src)
}
func (m *ConditionAggregator) XXX_Size() int {
	return m.Size()
}
func (m *ConditionAggregator) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionAggregator.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionAggregator proto.InternalMessageInfo

func (m *ConditionAggregator) GetCondition() *Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *ConditionAggregator) GetUnitId() int32 {
	if m != nil {
		return m.UnitId
	}
	return 0
}

func (m *ConditionAggregator) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *ConditionAggregator) GetDownSampling() string {
	if m != nil {
		return m.DownSampling
	}
	return ""
}

func (m *ConditionAggregator) GetAggregator() string {
	if m != nil {
		return m.Aggregator
	}
	return ""
}

type GroupByExpr struct {
	GroupBy              []string  `protobuf:"bytes,1,rep,name=groupBy,proto3" json:"groupBy,omitempty"`
	HavingClause         *BoolExpr `protobuf:"bytes,2,opt,name=havingClause,proto3" json:"havingClause,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GroupByExpr) Reset()         { *m = GroupByExpr{} }
func (m *GroupByExpr) String() string { return proto.CompactTextString(m) }
func (*GroupByExpr) ProtoMessage()    {}
func (*GroupByExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{25}
}
func (m *GroupByExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupByExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupByExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupByExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupByExpr.Merge(m, src)
}
func (m *GroupByExpr) XXX_Size() int {
	return m.Size()
}
func (m *GroupByExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupByExpr.DiscardUnknown(m)
}

var xxx_messageInfo_GroupByExpr proto.InternalMessageInfo

func (m *GroupByExpr) GetGroupBy() []string {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *GroupByExpr) GetHavingClause() *BoolExpr {
	if m != nil {
		return m.HavingClause
	}
	return nil
}

type QueryResult struct {
	Series               [][]byte `protobuf:"bytes,1,rep,name=series,proto3" json:"series,omitempty"`
	ExplainData          []byte   `protobuf:"bytes,3,opt,name=explainData,proto3" json:"explainData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryResult) Reset()         { *m = QueryResult{} }
func (m *QueryResult) String() string { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()    {}
func (*QueryResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{26}
}
func (m *QueryResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResult.Merge(m, src)
}
func (m *QueryResult) XXX_Size() int {
	return m.Size()
}
func (m *QueryResult) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResult.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResult proto.InternalMessageInfo

func (m *QueryResult) GetSeries() [][]byte {
	if m != nil {
		return m.Series
	}
	return nil
}

func (m *QueryResult) GetExplainData() []byte {
	if m != nil {
		return m.ExplainData
	}
	return nil
}

type FieldExpr struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Alias                string   `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FieldExpr) Reset()         { *m = FieldExpr{} }
func (m *FieldExpr) String() string { return proto.CompactTextString(m) }
func (*FieldExpr) ProtoMessage()    {}
func (*FieldExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{27}
}
func (m *FieldExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldExpr.Merge(m, src)
}
func (m *FieldExpr) XXX_Size() int {
	return m.Size()
}
func (m *FieldExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldExpr.DiscardUnknown(m)
}

var xxx_messageInfo_FieldExpr proto.InternalMessageInfo

func (m *FieldExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *FieldExpr) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

type OrderByExpr struct {
	Expr                 *Expr    `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Desc                 bool     `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderByExpr) Reset()         { *m = OrderByExpr{} }
func (m *OrderByExpr) String() string { return proto.CompactTextString(m) }
func (*OrderByExpr) ProtoMessage()    {}
func (*OrderByExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{28}
}
func (m *OrderByExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderByExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderByExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderByExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderByExpr.Merge(m, src)
}
func (m *OrderByExpr) XXX_Size() int {
	return m.Size()
}
func (m *OrderByExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderByExpr.DiscardUnknown(m)
}

var xxx_messageInfo_OrderByExpr proto.InternalMessageInfo

func (m *OrderByExpr) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *OrderByExpr) GetDesc() bool {
	if m != nil {
		return m.Desc
	}
	return false
}

type BoolExpr struct {
	// Types that are valid to be assigned to BoolExpr:
	//	*BoolExpr_Binary
	//	*BoolExpr_LogicJoinExpr
	BoolExpr             isBoolExpr_BoolExpr `protobuf_oneof:"boolExpr"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BoolExpr) Reset()         { *m = BoolExpr{} }
func (m *BoolExpr) String() string { return proto.CompactTextString(m) }
func (*BoolExpr) ProtoMessage()    {}
func (*BoolExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{29}
}
func (m *BoolExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoolExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoolExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoolExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolExpr.Merge(m, src)
}
func (m *BoolExpr) XXX_Size() int {
	return m.Size()
}
func (m *BoolExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolExpr.DiscardUnknown(m)
}

var xxx_messageInfo_BoolExpr proto.InternalMessageInfo

type isBoolExpr_BoolExpr interface {
	isBoolExpr_BoolExpr()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BoolExpr_Binary struct {
	Binary *BinaryExpr `protobuf:"bytes,1,opt,name=binary,proto3,oneof"`
}
type BoolExpr_LogicJoinExpr struct {
	LogicJoinExpr *LogicJoinExpr `protobuf:"bytes,2,opt,name=logicJoinExpr,proto3,oneof"`
}

func (*BoolExpr_Binary) isBoolExpr_BoolExpr()        {}
func (*BoolExpr_LogicJoinExpr) isBoolExpr_BoolExpr() {}

func (m *BoolExpr) GetBoolExpr() isBoolExpr_BoolExpr {
	if m != nil {
		return m.BoolExpr
	}
	return nil
}

func (m *BoolExpr) GetBinary() *BinaryExpr {
	if x, ok := m.GetBoolExpr().(*BoolExpr_Binary); ok {
		return x.Binary
	}
	return nil
}

func (m *BoolExpr) GetLogicJoinExpr() *LogicJoinExpr {
	if x, ok := m.GetBoolExpr().(*BoolExpr_LogicJoinExpr); ok {
		return x.LogicJoinExpr
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BoolExpr) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BoolExpr_OneofMarshaler, _BoolExpr_OneofUnmarshaler, _BoolExpr_OneofSizer, []interface{}{
		(*BoolExpr_Binary)(nil),
		(*BoolExpr_LogicJoinExpr)(nil),
	}
}

func _BoolExpr_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BoolExpr)
	// boolExpr
	switch x := m.BoolExpr.(type) {
	case *BoolExpr_Binary:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Binary); err != nil {
			return err
		}
	case *BoolExpr_LogicJoinExpr:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogicJoinExpr); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BoolExpr.BoolExpr has unexpected type %T", x)
	}
	return nil
}

func _BoolExpr_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BoolExpr)
	switch tag {
	case 1: // boolExpr.binary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BinaryExpr)
		err := b.DecodeMessage(msg)
		m.BoolExpr = &BoolExpr_Binary{msg}
		return true, err
	case 2: // boolExpr.logicJoinExpr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicJoinExpr)
		err := b.DecodeMessage(msg)
		m.BoolExpr = &BoolExpr_LogicJoinExpr{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BoolExpr_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BoolExpr)
	// boolExpr
	switch x := m.BoolExpr.(type) {
	case *BoolExpr_Binary:
		s := proto.Size(x.Binary)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BoolExpr_LogicJoinExpr:
		s := proto.Size(x.LogicJoinExpr)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LogicJoinExpr struct {
	LeftBoolExpr         *BoolExpr     `protobuf:"bytes,1,opt,name=leftBoolExpr,proto3" json:"leftBoolExpr,omitempty"`
	Op                   LogicOperator `protobuf:"varint,2,opt,name=op,proto3,enum=proto.LogicOperator" json:"op,omitempty"`
	RightBoolExpr        *BoolExpr     `protobuf:"bytes,3,opt,name=rightBoolExpr,proto3" json:"rightBoolExpr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LogicJoinExpr) Reset()         { *m = LogicJoinExpr{} }
func (m *LogicJoinExpr) String() string { return proto.CompactTextString(m) }
func (*LogicJoinExpr) ProtoMessage()    {}
func (*LogicJoinExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{30}
}
func (m *LogicJoinExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicJoinExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicJoinExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogicJoinExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicJoinExpr.Merge(m, src)
}
func (m *LogicJoinExpr) XXX_Size() int {
	return m.Size()
}
func (m *LogicJoinExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicJoinExpr.DiscardUnknown(m)
}

var xxx_messageInfo_LogicJoinExpr proto.InternalMessageInfo

func (m *LogicJoinExpr) GetLeftBoolExpr() *BoolExpr {
	if m != nil {
		return m.LeftBoolExpr
	}
	return nil
}

func (m *LogicJoinExpr) GetOp() LogicOperator {
	if m != nil {
		return m.Op
	}
	return LogicOperator_UNKNOWN
}

func (m *LogicJoinExpr) GetRightBoolExpr() *BoolExpr {
	if m != nil {
		return m.RightBoolExpr
	}
	return nil
}

type Expr struct {
	// Types that are valid to be assigned to Expr:
	//	*Expr_Call
	//	*Expr_Ref
	//	*Expr_Binary
	//	*Expr_LongVal
	//	*Expr_DoubleVal
	//	*Expr_Condition
	Expr                 isExpr_Expr `protobuf_oneof:"expr"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{31}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.Size()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

type isExpr_Expr interface {
	isExpr_Expr()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Expr_Call struct {
	Call *CallExpr `protobuf:"bytes,1,opt,name=call,proto3,oneof"`
}
type Expr_Ref struct {
	Ref *ValRefExpr `protobuf:"bytes,2,opt,name=ref,proto3,oneof"`
}
type Expr_Binary struct {
	Binary *BinaryExpr `protobuf:"bytes,3,opt,name=binary,proto3,oneof"`
}
type Expr_LongVal struct {
	LongVal *LongExpr `protobuf:"bytes,4,opt,name=longVal,proto3,oneof"`
}
type Expr_DoubleVal struct {
	DoubleVal *DoubleExpr `protobuf:"bytes,5,opt,name=doubleVal,proto3,oneof"`
}
type Expr_Condition struct {
	Condition *Condition `protobuf:"bytes,6,opt,name=condition,proto3,oneof"`
}

func (*Expr_Call) isExpr_Expr()      {}
func (*Expr_Ref) isExpr_Expr()       {}
func (*Expr_Binary) isExpr_Expr()    {}
func (*Expr_LongVal) isExpr_Expr()   {}
func (*Expr_DoubleVal) isExpr_Expr() {}
func (*Expr_Condition) isExpr_Expr() {}

func (m *Expr) GetExpr() isExpr_Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *Expr) GetCall() *CallExpr {
	if x, ok := m.GetExpr().(*Expr_Call); ok {
		return x.Call
	}
	return nil
}

func (m *Expr) GetRef() *ValRefExpr {
	if x, ok := m.GetExpr().(*Expr_Ref); ok {
		return x.Ref
	}
	return nil
}

func (m *Expr) GetBinary() *BinaryExpr {
	if x, ok := m.GetExpr().(*Expr_Binary); ok {
		return x.Binary
	}
	return nil
}

func (m *Expr) GetLongVal() *LongExpr {
	if x, ok := m.GetExpr().(*Expr_LongVal); ok {
		return x.LongVal
	}
	return nil
}

func (m *Expr) GetDoubleVal() *DoubleExpr {
	if x, ok := m.GetExpr().(*Expr_DoubleVal); ok {
		return x.DoubleVal
	}
	return nil
}

func (m *Expr) GetCondition() *Condition {
	if x, ok := m.GetExpr().(*Expr_Condition); ok {
		return x.Condition
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Expr) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Expr_OneofMarshaler, _Expr_OneofUnmarshaler, _Expr_OneofSizer, []interface{}{
		(*Expr_Call)(nil),
		(*Expr_Ref)(nil),
		(*Expr_Binary)(nil),
		(*Expr_LongVal)(nil),
		(*Expr_DoubleVal)(nil),
		(*Expr_Condition)(nil),
	}
}

func _Expr_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Expr)
	// expr
	switch x := m.Expr.(type) {
	case *Expr_Call:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Call); err != nil {
			return err
		}
	case *Expr_Ref:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ref); err != nil {
			return err
		}
	case *Expr_Binary:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Binary); err != nil {
			return err
		}
	case *Expr_LongVal:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LongVal); err != nil {
			return err
		}
	case *Expr_DoubleVal:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DoubleVal); err != nil {
			return err
		}
	case *Expr_Condition:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Condition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Expr.Expr has unexpected type %T", x)
	}
	return nil
}

func _Expr_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Expr)
	switch tag {
	case 1: // expr.call
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CallExpr)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Call{msg}
		return true, err
	case 2: // expr.ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ValRefExpr)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Ref{msg}
		return true, err
	case 3: // expr.binary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BinaryExpr)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Binary{msg}
		return true, err
	case 4: // expr.longVal
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LongExpr)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_LongVal{msg}
		return true, err
	case 5: // expr.doubleVal
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DoubleExpr)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_DoubleVal{msg}
		return true, err
	case 6: // expr.condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Condition)
		err := b.DecodeMessage(msg)
		m.Expr = &Expr_Condition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Expr_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Expr)
	// expr
	switch x := m.Expr.(type) {
	case *Expr_Call:
		s := proto.Size(x.Call)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_Ref:
		s := proto.Size(x.Ref)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_Binary:
		s := proto.Size(x.Binary)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_LongVal:
		s := proto.Size(x.LongVal)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_DoubleVal:
		s := proto.Size(x.DoubleVal)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Expr_Condition:
		s := proto.Size(x.Condition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CallExpr struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Args                 []*Expr  `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CallExpr) Reset()         { *m = CallExpr{} }
func (m *CallExpr) String() string { return proto.CompactTextString(m) }
func (*CallExpr) ProtoMessage()    {}
func (*CallExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{32}
}
func (m *CallExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallExpr.Merge(m, src)
}
func (m *CallExpr) XXX_Size() int {
	return m.Size()
}
func (m *CallExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_CallExpr.DiscardUnknown(m)
}

var xxx_messageInfo_CallExpr proto.InternalMessageInfo

func (m *CallExpr) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CallExpr) GetArgs() []*Expr {
	if m != nil {
		return m.Args
	}
	return nil
}

type LongExpr struct {
	Value                int64    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LongExpr) Reset()         { *m = LongExpr{} }
func (m *LongExpr) String() string { return proto.CompactTextString(m) }
func (*LongExpr) ProtoMessage()    {}
func (*LongExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{33}
}
func (m *LongExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LongExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LongExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LongExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LongExpr.Merge(m, src)
}
func (m *LongExpr) XXX_Size() int {
	return m.Size()
}
func (m *LongExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_LongExpr.DiscardUnknown(m)
}

var xxx_messageInfo_LongExpr proto.InternalMessageInfo

func (m *LongExpr) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type DoubleExpr struct {
	Value                float64  `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DoubleExpr) Reset()         { *m = DoubleExpr{} }
func (m *DoubleExpr) String() string { return proto.CompactTextString(m) }
func (*DoubleExpr) ProtoMessage()    {}
func (*DoubleExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{34}
}
func (m *DoubleExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleExpr.Merge(m, src)
}
func (m *DoubleExpr) XXX_Size() int {
	return m.Size()
}
func (m *DoubleExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleExpr.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleExpr proto.InternalMessageInfo

func (m *DoubleExpr) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type BinaryExpr struct {
	Left                 *Expr    `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Op                   Operator `protobuf:"varint,2,opt,name=op,proto3,enum=proto.Operator" json:"op,omitempty"`
	Right                *Expr    `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BinaryExpr) Reset()         { *m = BinaryExpr{} }
func (m *BinaryExpr) String() string { return proto.CompactTextString(m) }
func (*BinaryExpr) ProtoMessage()    {}
func (*BinaryExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{35}
}
func (m *BinaryExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinaryExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinaryExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinaryExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinaryExpr.Merge(m, src)
}
func (m *BinaryExpr) XXX_Size() int {
	return m.Size()
}
func (m *BinaryExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_BinaryExpr.DiscardUnknown(m)
}

var xxx_messageInfo_BinaryExpr proto.InternalMessageInfo

func (m *BinaryExpr) GetLeft() *Expr {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *BinaryExpr) GetOp() Operator {
	if m != nil {
		return m.Op
	}
	return Operator_EQUAL
}

func (m *BinaryExpr) GetRight() *Expr {
	if m != nil {
		return m.Right
	}
	return nil
}

type ValRefExpr struct {
	RefName              string   `protobuf:"bytes,1,opt,name=refName,proto3" json:"refName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValRefExpr) Reset()         { *m = ValRefExpr{} }
func (m *ValRefExpr) String() string { return proto.CompactTextString(m) }
func (*ValRefExpr) ProtoMessage()    {}
func (*ValRefExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{36}
}
func (m *ValRefExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValRefExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValRefExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValRefExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValRefExpr.Merge(m, src)
}
func (m *ValRefExpr) XXX_Size() int {
	return m.Size()
}
func (m *ValRefExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_ValRefExpr.DiscardUnknown(m)
}

var xxx_messageInfo_ValRefExpr proto.InternalMessageInfo

func (m *ValRefExpr) GetRefName() string {
	if m != nil {
		return m.RefName
	}
	return ""
}

type Series struct {
	BaseTime             int64            `protobuf:"varint,1,opt,name=baseTime,proto3" json:"baseTime,omitempty"`
	Interval             int64            `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Start                int32            `protobuf:"varint,3,opt,name=start,proto3" json:"start,omitempty"`
	End                  int32            `protobuf:"varint,4,opt,name=end,proto3" json:"end,omitempty"`
	Group                *Tag             `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty"`
	Aggregators          []*Aggregator    `protobuf:"bytes,6,rep,name=aggregators,proto3" json:"aggregators,omitempty"`
	Fields               map[int32][]byte `protobuf:"bytes,7,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	GroupValue           float64          `protobuf:"fixed64,8,opt,name=groupValue,proto3" json:"groupValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Series) Reset()         { *m = Series{} }
func (m *Series) String() string { return proto.CompactTextString(m) }
func (*Series) ProtoMessage()    {}
func (*Series) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{37}
}
func (m *Series) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Series) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Series.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Series) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Series.Merge(m, src)
}
func (m *Series) XXX_Size() int {
	return m.Size()
}
func (m *Series) XXX_DiscardUnknown() {
	xxx_messageInfo_Series.DiscardUnknown(m)
}

var xxx_messageInfo_Series proto.InternalMessageInfo

func (m *Series) GetBaseTime() int64 {
	if m != nil {
		return m.BaseTime
	}
	return 0
}

func (m *Series) GetInterval() int64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *Series) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Series) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Series) GetGroup() *Tag {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *Series) GetAggregators() []*Aggregator {
	if m != nil {
		return m.Aggregators
	}
	return nil
}

func (m *Series) GetFields() map[int32][]byte {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Series) GetGroupValue() float64 {
	if m != nil {
		return m.GroupValue
	}
	return 0
}

type Aggregator struct {
	UnitId               int32    `protobuf:"varint,1,opt,name=unitId,proto3" json:"unitId,omitempty"`
	Fun                  string   `protobuf:"bytes,2,opt,name=fun,proto3" json:"fun,omitempty"`
	FieldType            string   `protobuf:"bytes,3,opt,name=fieldType,proto3" json:"fieldType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Aggregator) Reset()         { *m = Aggregator{} }
func (m *Aggregator) String() string { return proto.CompactTextString(m) }
func (*Aggregator) ProtoMessage()    {}
func (*Aggregator) Descriptor() ([]byte, []int) {
	return fileDescriptor_4430318ac3171d1a, []int{38}
}
func (m *Aggregator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregator.Merge(m, src)
}
func (m *Aggregator) XXX_Size() int {
	return m.Size()
}
func (m *Aggregator) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregator.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregator proto.InternalMessageInfo

func (m *Aggregator) GetUnitId() int32 {
	if m != nil {
		return m.UnitId
	}
	return 0
}

func (m *Aggregator) GetFun() string {
	if m != nil {
		return m.Fun
	}
	return ""
}

func (m *Aggregator) GetFieldType() string {
	if m != nil {
		return m.FieldType
	}
	return ""
}

func init() {
	proto.RegisterType((*Stmt)(nil), "proto.Stmt")
	proto.RegisterType((*ResultSet)(nil), "proto.ResultSet")
	proto.RegisterType((*DropDatabase)(nil), "proto.DropDatabase")
	proto.RegisterType((*ShowDatabases)(nil), "proto.ShowDatabases")
	proto.RegisterType((*ShowNode)(nil), "proto.ShowNode")
	proto.RegisterType((*ShowNodeResult)(nil), "proto.ShowNodeResult")
	proto.RegisterType((*ShowDatabasesResult)(nil), "proto.ShowDatabasesResult")
	proto.RegisterType((*ShowStats)(nil), "proto.ShowStats")
	proto.RegisterType((*ShowStatsResult)(nil), "proto.ShowStatsResult")
	proto.RegisterType((*ShowMetric)(nil), "proto.ShowMetric")
	proto.RegisterType((*ShowMetricResult)(nil), "proto.ShowMetricResult")
	proto.RegisterType((*ShowFieldKeys)(nil), "proto.ShowFieldKeys")
	proto.RegisterType((*ShowFieldKeysResult)(nil), "proto.ShowFieldKeysResult")
	proto.RegisterMapType((map[string]string)(nil), "proto.ShowFieldKeysResult.FieldsEntry")
	proto.RegisterType((*ShowInfoResult)(nil), "proto.ShowInfoResult")
	proto.RegisterMapType((map[string]string)(nil), "proto.ShowInfoResult.InfoEntry")
	proto.RegisterType((*ShowTagKeys)(nil), "proto.ShowTagKeys")
	proto.RegisterType((*ShowInfo)(nil), "proto.ShowInfo")
	proto.RegisterType((*ShowTagKeysResult)(nil), "proto.ShowTagKeysResult")
	proto.RegisterType((*ShowTagValues)(nil), "proto.ShowTagValues")
	proto.RegisterType((*ShowTagValuesResult)(nil), "proto.ShowTagValuesResult")
	proto.RegisterType((*ShowTagValuesInfo)(nil), "proto.ShowTagValuesInfo")
	proto.RegisterType((*ShowTagValuesInfoResult)(nil), "proto.ShowTagValuesInfoResult")
	proto.RegisterMapType((map[string]string)(nil), "proto.ShowTagValuesInfoResult.InfoEntry")
	proto.RegisterType((*ShowQueries)(nil), "proto.ShowQueries")
	proto.RegisterType((*KillQuery)(nil), "proto.KillQuery")
	proto.RegisterType((*Query)(nil), "proto.Query")
	proto.RegisterType((*ConditionAggregator)(nil), "proto.ConditionAggregator")
	proto.RegisterType((*GroupByExpr)(nil), "proto.GroupByExpr")
	proto.RegisterType((*QueryResult)(nil), "proto.QueryResult")
	proto.RegisterType((*FieldExpr)(nil), "proto.FieldExpr")
	proto.RegisterType((*OrderByExpr)(nil), "proto.OrderByExpr")
	proto.RegisterType((*BoolExpr)(nil), "proto.BoolExpr")
	proto.RegisterType((*LogicJoinExpr)(nil), "proto.LogicJoinExpr")
	proto.RegisterType((*Expr)(nil), "proto.Expr")
	proto.RegisterType((*CallExpr)(nil), "proto.CallExpr")
	proto.RegisterType((*LongExpr)(nil), "proto.LongExpr")
	proto.RegisterType((*DoubleExpr)(nil), "proto.DoubleExpr")
	proto.RegisterType((*BinaryExpr)(nil), "proto.BinaryExpr")
	proto.RegisterType((*ValRefExpr)(nil), "proto.ValRefExpr")
	proto.RegisterType((*Series)(nil), "proto.Series")
	proto.RegisterMapType((map[int32][]byte)(nil), "proto.Series.FieldsEntry")
	proto.RegisterType((*Aggregator)(nil), "proto.Aggregator")
}

func init() { proto.RegisterFile("statement.proto", fileDescriptor_4430318ac3171d1a) }

var fileDescriptor_4430318ac3171d1a = []byte{
	// 1749 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6f, 0x14, 0xc9,
	0x15, 0x9f, 0x9e, 0x2f, 0x4f, 0xbf, 0x19, 0x7f, 0x50, 0x76, 0xcc, 0xc4, 0x8a, 0x6c, 0xa7, 0x04,
	0x08, 0x01, 0xb1, 0x20, 0x4e, 0x9c, 0x10, 0xa1, 0x44, 0x0c, 0x06, 0x86, 0x40, 0x8c, 0x52, 0xb6,
	0x38, 0xe5, 0xd2, 0xf6, 0xd4, 0x0c, 0x2d, 0x7a, 0xba, 0x87, 0xee, 0x1e, 0x83, 0x8f, 0xf9, 0x17,
	0x72, 0x8a, 0x94, 0x53, 0xce, 0xb9, 0x45, 0x91, 0xf2, 0x27, 0xec, 0x5e, 0x56, 0xda, 0xf3, 0x9e,
	0x56, 0xec, 0x3f, 0xb1, 0xda, 0xd3, 0xea, 0xd5, 0x57, 0x57, 0xcd, 0xb4, 0xb1, 0x77, 0xb5, 0x9c,
	0xba, 0xdf, 0x57, 0xbd, 0x8f, 0xfa, 0xbd, 0x7a, 0x55, 0xb0, 0x9c, 0xe5, 0x41, 0xce, 0xc7, 0x3c,
	0xce, 0x77, 0x26, 0x69, 0x92, 0x27, 0xa4, 0x21, 0x3e, 0x1b, 0x9d, 0x93, 0x64, 0x3c, 0x4e, 0xe2,
	0x1d, 0x45, 0x0d, 0xc3, 0x28, 0xe7, 0xa9, 0xa2, 0x00, 0x6d, 0xe4, 0x3f, 0xfd, 0xaa, 0x01, 0xf5,
	0xc3, 0x7c, 0x9c, 0x93, 0x07, 0xb0, 0x98, 0xbd, 0x4e, 0xde, 0xed, 0x07, 0x79, 0x70, 0x1c, 0x64,
	0x3c, 0xeb, 0x7a, 0xdb, 0xde, 0xcd, 0xf6, 0xaf, 0xd7, 0xa4, 0xde, 0xce, 0xa1, 0x2d, 0xeb, 0x57,
	0x98, 0xab, 0x4c, 0xee, 0x82, 0x8f, 0x8c, 0xc3, 0x3c, 0xc8, 0xb3, 0x6e, 0x55, 0x58, 0xae, 0x58,
	0x96, 0x82, 0xdf, 0xaf, 0xb0, 0x42, 0x89, 0xec, 0x02, 0x20, 0xf1, 0x17, 0x9e, 0xa7, 0xe1, 0x49,
	0xb7, 0x26, 0x4c, 0xae, 0x58, 0x26, 0x52, 0xd0, 0xaf, 0x30, 0x4b, 0x4d, 0x07, 0xf9, 0x24, 0xe4,
	0xd1, 0xe0, 0x39, 0x3f, 0xcb, 0xba, 0xf5, 0xb9, 0x20, 0x8d, 0x4c, 0x07, 0x69, 0x18, 0x64, 0x0f,
	0xda, 0xc8, 0x38, 0x0a, 0x46, 0xc2, 0xb6, 0x21, 0x6c, 0x89, 0x65, 0xab, 0x24, 0xfd, 0x0a, 0xb3,
	0x15, 0xb5, 0xd7, 0xa3, 0x60, 0xf4, 0x2a, 0x88, 0xa6, 0x3c, 0xeb, 0x36, 0xe7, 0xbc, 0x1a, 0x99,
	0xf6, 0x6a, 0x18, 0xda, 0xeb, 0x5f, 0xa7, 0x3c, 0x0d, 0x79, 0xd6, 0x5d, 0x98, 0xf3, 0xaa, 0x24,
	0xda, 0xab, 0x22, 0xb1, 0xa4, 0x6f, 0xc2, 0x28, 0x42, 0xf2, 0xac, 0xdb, 0x72, 0x4a, 0xfa, 0x5c,
	0xf3, 0xb1, 0xa4, 0x46, 0x89, 0x5c, 0x83, 0xc6, 0x5b, 0xa1, 0xed, 0x0b, 0xed, 0x8e, 0xd2, 0xd6,
	0x9a, 0x52, 0x48, 0x7e, 0x05, 0x2d, 0x74, 0x73, 0x90, 0x0c, 0x78, 0xb7, 0x2d, 0x14, 0x97, 0xad,
	0x60, 0x90, 0xdd, 0xaf, 0x30, 0xa3, 0x42, 0xee, 0x43, 0x67, 0x90, 0x26, 0x13, 0xbd, 0xd5, 0xdd,
	0x45, 0x61, 0xb2, 0xaa, 0x4c, 0xf6, 0x2d, 0x51, 0xbf, 0xc2, 0x1c, 0x55, 0xed, 0xe9, 0x59, 0x3c,
	0x4c, 0xba, 0x4b, 0x73, 0x9e, 0x90, 0xad, 0x3d, 0xe1, 0x3f, 0xe9, 0xc3, 0x15, 0xa7, 0x72, 0xc2,
	0x6e, 0x59, 0xd8, 0x75, 0xcb, 0x4a, 0xad, 0x16, 0x98, 0x37, 0xea, 0x35, 0xa1, 0x9e, 0xe5, 0xe3,
	0x9c, 0x7e, 0x5b, 0x07, 0x9f, 0xf1, 0x6c, 0x1a, 0xe5, 0x87, 0x3c, 0x27, 0xbd, 0x72, 0x84, 0x6f,
	0x94, 0x21, 0x5c, 0x5a, 0xcd, 0xe3, 0x7c, 0x6f, 0x1e, 0xe7, 0xeb, 0xb3, 0x38, 0x37, 0xb6, 0x16,
	0xda, 0xef, 0x97, 0xa0, 0xfd, 0xea, 0x1c, 0xda, 0x8d, 0xa5, 0x8b, 0x79, 0x07, 0xb5, 0xf5, 0xb2,
	0x82, 0xa0, 0xc4, 0x18, 0x3b, 0xd8, 0xed, 0xcd, 0x62, 0xb7, 0x31, 0x97, 0xb4, 0x91, 0xb9, 0x49,
	0x17, 0x08, 0xee, 0xcd, 0x76, 0x5d, 0x73, 0x6e, 0x0d, 0x23, 0x73, 0xd7, 0x28, 0x7a, 0xef, 0x96,
	0xc6, 0xa6, 0x8b, 0x7f, 0x81, 0x4d, 0x63, 0xa3, 0x10, 0xba, 0x6b, 0x21, 0x54, 0x02, 0xff, 0x67,
	0x33, 0x08, 0x35, 0x16, 0x05, 0x4e, 0x77, 0x2d, 0xb0, 0xf9, 0x73, 0x46, 0xc8, 0x76, 0x8d, 0x04,
	0xe4, 0x0e, 0xca, 0x20, 0x07, 0xc2, 0x7a, 0xf3, 0x3c, 0xc8, 0x99, 0x65, 0x4a, 0x80, 0xd7, 0x82,
	0x66, 0x2a, 0xc4, 0xf4, 0x16, 0x74, 0xec, 0xde, 0x20, 0x1b, 0xd0, 0x1a, 0xe8, 0x16, 0x42, 0xdc,
	0xf9, 0xcc, 0xd0, 0x74, 0x19, 0x16, 0x1d, 0xf0, 0x51, 0x80, 0x96, 0xce, 0x94, 0xae, 0xc0, 0x92,
	0x9b, 0x35, 0xbd, 0x07, 0xab, 0x25, 0x58, 0x9d, 0xf1, 0x50, 0x73, 0x3c, 0x3c, 0x04, 0xdf, 0xc0,
	0x93, 0xac, 0x43, 0x73, 0x9c, 0x0c, 0xa6, 0x91, 0x0e, 0x44, 0x51, 0xe4, 0x17, 0xe0, 0x9f, 0x24,
	0xe3, 0x49, 0x12, 0xf3, 0x38, 0x17, 0xd8, 0xf6, 0x59, 0xc1, 0xa0, 0xff, 0xf0, 0x60, 0x79, 0x06,
	0xe2, 0xe4, 0x01, 0x2c, 0x69, 0x17, 0xc8, 0xe6, 0x59, 0xb7, 0xb6, 0x5d, 0xb3, 0x4e, 0xc6, 0x7d,
	0x5b, 0xc8, 0x66, 0x74, 0xc9, 0x43, 0x2c, 0x7e, 0x90, 0x0e, 0x9e, 0x24, 0x29, 0x66, 0x27, 0xb8,
	0xdd, 0x86, 0x58, 0x60, 0xd5, 0x14, 0xbf, 0x90, 0xb3, 0x79, 0x6d, 0xba, 0x07, 0x50, 0x74, 0x0f,
	0x21, 0x50, 0x8f, 0x83, 0xb1, 0x4e, 0x4b, 0xfc, 0x93, 0x35, 0x68, 0x44, 0xe1, 0x38, 0x94, 0x09,
	0x35, 0x98, 0x24, 0xe8, 0x0d, 0x58, 0x99, 0xed, 0x3a, 0xcb, 0xba, 0xa6, 0xad, 0xe9, 0x53, 0xb9,
	0x33, 0x05, 0x8c, 0xb7, 0xa1, 0x3d, 0xe6, 0x41, 0x36, 0x4d, 0xc5, 0xc8, 0x55, 0x9e, 0x6c, 0xd6,
	0x39, 0x0e, 0xff, 0xeb, 0xc9, 0x4d, 0x9b, 0xe9, 0x93, 0x4b, 0xac, 0xf7, 0x47, 0x68, 0x0e, 0xd1,
	0x08, 0x8f, 0x1b, 0x2c, 0xcd, 0x8d, 0xf3, 0xbb, 0x6e, 0x47, 0xd0, 0xd9, 0xe3, 0x38, 0x4f, 0xcf,
	0x98, 0xb2, 0xda, 0xb8, 0x0f, 0x6d, 0x8b, 0x4d, 0x56, 0xa0, 0xf6, 0x86, 0x9f, 0x29, 0x47, 0xf8,
	0x8b, 0x01, 0x9f, 0x22, 0x82, 0xd5, 0x96, 0x4b, 0xe2, 0x0f, 0xd5, 0xdf, 0x7b, 0xf4, 0x7f, 0x9e,
	0xc4, 0x5e, 0x81, 0xfa, 0x4b, 0xc4, 0x8b, 0x65, 0xc4, 0xc6, 0xad, 0xaa, 0x4d, 0x90, 0xbd, 0x59,
	0x0f, 0xb1, 0xb3, 0x24, 0x3a, 0xb6, 0x4a, 0xfb, 0x72, 0x07, 0x7f, 0x65, 0xe8, 0x42, 0x79, 0xe3,
	0x77, 0xe0, 0x1b, 0xd6, 0x0f, 0x0a, 0xfb, 0x31, 0xb4, 0xad, 0x63, 0xf1, 0x47, 0x6f, 0xd9, 0x1d,
	0xd9, 0x84, 0xe2, 0x9c, 0xb8, 0x70, 0x0d, 0xfa, 0x12, 0xae, 0xcc, 0x9d, 0xc5, 0x97, 0x70, 0xdd,
	0x85, 0x85, 0x5c, 0x1d, 0xec, 0x55, 0x81, 0x3b, 0x4d, 0xd2, 0xff, 0x78, 0x12, 0x7b, 0xc5, 0x31,
	0x7c, 0xf1, 0x6a, 0xeb, 0xd0, 0x94, 0xe6, 0xaa, 0x28, 0x8a, 0xc2, 0xa3, 0x21, 0x57, 0xcb, 0x88,
	0xd9, 0xe3, 0x33, 0x43, 0x17, 0xc9, 0xd7, 0xad, 0xe4, 0xc9, 0x0e, 0x9e, 0x05, 0xf1, 0x20, 0xcc,
	0xc3, 0x24, 0x56, 0x23, 0x43, 0x5f, 0x3e, 0x1e, 0x69, 0x3e, 0x2b, 0x54, 0x68, 0x20, 0xe1, 0x3d,
	0x33, 0x4a, 0x2e, 0x11, 0xb2, 0xda, 0xd8, 0x6a, 0xb1, 0xb1, 0xeb, 0xd0, 0x3c, 0x95, 0xa3, 0xaa,
	0x26, 0x2a, 0xa2, 0x28, 0x1a, 0x9a, 0x0a, 0x17, 0x07, 0xee, 0xa7, 0xa9, 0x09, 0xfd, 0xce, 0x83,
	0xab, 0xe7, 0x9c, 0xfb, 0x9f, 0x68, 0x17, 0x74, 0xd7, 0xd4, 0xad, 0xae, 0x79, 0xa0, 0xba, 0x46,
	0x1e, 0x89, 0x37, 0x3f, 0x3e, 0x8f, 0x7e, 0xba, 0xf6, 0x59, 0x94, 0xed, 0xa3, 0xae, 0xa1, 0x38,
	0x3a, 0xcc, 0x75, 0x13, 0xe1, 0x2a, 0x46, 0xf4, 0xb3, 0x81, 0x58, 0xab, 0xc6, 0x34, 0x89, 0xc9,
	0x65, 0x3c, 0x3d, 0xe5, 0xe9, 0xb3, 0x81, 0x6a, 0x23, 0x43, 0xd3, 0xcf, 0x6a, 0xd0, 0x90, 0xf6,
	0x17, 0x17, 0x6f, 0x07, 0xfc, 0x3c, 0x1c, 0x73, 0x16, 0xc4, 0x23, 0x3e, 0xf3, 0x90, 0x38, 0xd2,
	0x7c, 0x56, 0xa8, 0xa0, 0xdf, 0x30, 0xce, 0x79, 0x7a, 0x1a, 0x44, 0xa2, 0xa8, 0x35, 0x66, 0x68,
	0xb2, 0x07, 0x8b, 0xe2, 0x10, 0x7c, 0xfc, 0x7e, 0x92, 0xbe, 0x08, 0x33, 0x84, 0x78, 0xcd, 0x5a,
	0xef, 0x89, 0x96, 0x31, 0x57, 0x8d, 0x1c, 0xc0, 0x9a, 0x41, 0xf6, 0xc3, 0xd1, 0x28, 0xe5, 0xa3,
	0x20, 0x4f, 0xd2, 0x4c, 0x6d, 0xc4, 0xc6, 0x6c, 0x1f, 0x14, 0x2a, 0xac, 0xd4, 0xce, 0x6d, 0xa6,
	0xe6, 0x85, 0xcd, 0x44, 0xee, 0xc0, 0x42, 0x92, 0x0e, 0x78, 0xda, 0x9b, 0xbd, 0x2d, 0xbd, 0x94,
	0x5c, 0x11, 0xb3, 0x56, 0x21, 0xbf, 0x81, 0xf6, 0x28, 0x4d, 0xa6, 0x13, 0xc9, 0x57, 0x17, 0x26,
	0x6d, 0xf1, 0xb4, 0x90, 0x30, 0x5b, 0xad, 0x68, 0x7b, 0xdf, 0x6e, 0xfb, 0x4d, 0x00, 0x5d, 0xbd,
	0xde, 0x99, 0xb8, 0x08, 0xf9, 0xcc, 0xe2, 0xd0, 0xff, 0x7b, 0xb0, 0x5a, 0x92, 0xb7, 0x9b, 0xa1,
	0x77, 0x71, 0x86, 0xeb, 0xd0, 0x9c, 0xc6, 0x61, 0x6e, 0xb0, 0xa2, 0x28, 0x8c, 0x4a, 0x6c, 0x85,
	0xea, 0x0f, 0x49, 0x10, 0x0a, 0x9d, 0x41, 0xf2, 0x2e, 0x3e, 0x0c, 0xc6, 0x93, 0x28, 0x8c, 0x47,
	0xaa, 0x49, 0x1c, 0x1e, 0x46, 0x1e, 0x98, 0x78, 0xc4, 0x89, 0xe5, 0x33, 0x8b, 0x43, 0xff, 0x06,
	0x6d, 0xab, 0x16, 0x08, 0x64, 0x55, 0x0d, 0x35, 0xef, 0x35, 0x49, 0x76, 0xa1, 0xf3, 0x3a, 0x38,
	0x0d, 0xe3, 0xd1, 0xa3, 0x28, 0x98, 0x66, 0x1a, 0x83, 0xfa, 0xe1, 0xd2, 0x4b, 0x92, 0x48, 0x14,
	0xd3, 0x51, 0xa2, 0x4f, 0xa1, 0x6d, 0xdd, 0x64, 0x31, 0xbd, 0x4c, 0xbe, 0xf6, 0x70, 0xf1, 0x0e,
	0x53, 0x14, 0xc2, 0x9f, 0xbf, 0x9f, 0x44, 0x41, 0x18, 0xe3, 0xcd, 0x48, 0x24, 0xd9, 0x61, 0x36,
	0x8b, 0xf6, 0xc0, 0x37, 0xb0, 0x24, 0x5b, 0x50, 0xe7, 0xb8, 0xa5, 0xb2, 0xa0, 0x6d, 0x15, 0x82,
	0x70, 0x2f, 0x04, 0x58, 0xae, 0x20, 0x0a, 0x83, 0x4c, 0x37, 0xb1, 0x20, 0x68, 0x0f, 0xda, 0x16,
	0x50, 0x2e, 0x5e, 0x85, 0x40, 0x7d, 0xc0, 0xb3, 0x13, 0xb1, 0x48, 0x8b, 0x89, 0x7f, 0xfa, 0x77,
	0x0f, 0x5a, 0x3a, 0x57, 0x72, 0x1b, 0x9a, 0xc7, 0x61, 0x1c, 0xa4, 0x67, 0x6a, 0x0d, 0xfd, 0x4c,
	0xef, 0x09, 0x26, 0xaa, 0xf4, 0x2b, 0x4c, 0xa9, 0xe0, 0x63, 0x39, 0x4a, 0x46, 0xe1, 0xc9, 0x9f,
	0x93, 0x30, 0x16, 0x80, 0xac, 0x3a, 0x8f, 0xe5, 0x17, 0xb6, 0x0c, 0x9f, 0x09, 0x8e, 0x72, 0x0f,
	0xa0, 0x75, 0xac, 0xdc, 0xd2, 0x7f, 0x7b, 0xb0, 0xe8, 0xa8, 0xe3, 0xde, 0x44, 0x7c, 0x98, 0xeb,
	0xc0, 0x54, 0x38, 0xf3, 0x7b, 0x63, 0x2b, 0x91, 0x6b, 0x50, 0x4d, 0x26, 0x22, 0x8a, 0x25, 0x37,
	0x8a, 0x97, 0x13, 0x9e, 0x8a, 0xae, 0xad, 0x26, 0x13, 0xf2, 0x5b, 0x58, 0x4c, 0xc3, 0xd1, 0xeb,
	0x62, 0xed, 0x5a, 0xf9, 0xda, 0xae, 0x16, 0xfd, 0x57, 0x15, 0xea, 0xc2, 0xcb, 0x75, 0xa8, 0x9f,
	0x04, 0x51, 0x34, 0x13, 0xd2, 0xa3, 0x20, 0x8a, 0x54, 0xa2, 0x42, 0x4c, 0xae, 0x43, 0x2d, 0xe5,
	0x43, 0x55, 0x13, 0x5d, 0xc7, 0x57, 0x41, 0xc4, 0xf8, 0x50, 0xe9, 0xa1, 0xdc, 0xaa, 0x78, 0xed,
	0xe2, 0x8a, 0xdf, 0x86, 0x85, 0x28, 0x89, 0x71, 0x22, 0xa8, 0xc7, 0xe1, 0xb2, 0xc9, 0x32, 0x1e,
	0x29, 0x5d, 0xad, 0x41, 0xee, 0x81, 0x3f, 0x48, 0xa6, 0xc7, 0x11, 0x47, 0xf5, 0x86, 0xb3, 0xf8,
	0xbe, 0xe0, 0x2b, 0x83, 0x42, 0x8b, 0xdc, 0xbd, 0xc4, 0xf1, 0x85, 0x16, 0x46, 0x09, 0xdf, 0xdf,
	0x88, 0x2c, 0xfa, 0x27, 0x68, 0xe9, 0x0a, 0x94, 0x5e, 0xce, 0xb7, 0xa0, 0x1e, 0xa4, 0x23, 0x7d,
	0xb3, 0x75, 0xa1, 0x89, 0x02, 0xba, 0x0d, 0x2d, 0x9d, 0x44, 0x31, 0xb1, 0xe4, 0xe4, 0x91, 0x04,
	0xa5, 0x00, 0x45, 0xdc, 0xae, 0x8e, 0xa7, 0x75, 0xde, 0x02, 0x14, 0x85, 0x43, 0xa7, 0x88, 0x8f,
	0xd2, 0x7e, 0x40, 0x01, 0xd9, 0xb2, 0x00, 0xa3, 0x4b, 0xe9, 0x60, 0xe5, 0x97, 0xd0, 0x10, 0x28,
	0x50, 0x9b, 0xe3, 0x2c, 0x21, 0x25, 0xf4, 0x06, 0x40, 0xb1, 0xab, 0x78, 0xda, 0xa4, 0x7c, 0x78,
	0x50, 0xa4, 0xaf, 0x49, 0xfa, 0x45, 0x15, 0x9a, 0x87, 0xf2, 0x70, 0xd8, 0x80, 0x16, 0x3e, 0x8e,
	0x70, 0xca, 0xa9, 0x14, 0x0d, 0xed, 0x4c, 0xb9, 0xea, 0xcc, 0x94, 0x5b, 0x83, 0x46, 0x96, 0x07,
	0xa9, 0x8c, 0xa6, 0xc1, 0x24, 0x81, 0x13, 0x9f, 0xc7, 0x03, 0x75, 0xa9, 0xc3, 0x5f, 0xb2, 0x0d,
	0x0d, 0x71, 0xc6, 0xa9, 0x5d, 0x07, 0x3d, 0x55, 0x83, 0x11, 0x93, 0x02, 0xb2, 0x0b, 0xed, 0xc0,
	0x1a, 0x77, 0x4d, 0xb1, 0x2b, 0x1a, 0x1d, 0xd6, 0x94, 0xb3, 0xb5, 0xc8, 0x3d, 0xf3, 0x3e, 0x59,
	0x10, 0xfa, 0x3f, 0xd7, 0xf7, 0x14, 0x91, 0x55, 0xd9, 0x93, 0x04, 0xcf, 0x6a, 0xe1, 0x50, 0x5e,
	0x85, 0x5a, 0x62, 0xab, 0x2c, 0xce, 0x47, 0x9e, 0x2c, 0x8d, 0x92, 0xcb, 0x4b, 0xc7, 0xbe, 0xbc,
	0x1c, 0x01, 0x58, 0x63, 0xa9, 0x18, 0x33, 0x9e, 0x33, 0x66, 0x56, 0xa0, 0x36, 0x9c, 0xc6, 0xfa,
	0xd2, 0x39, 0x9c, 0xc6, 0xf8, 0xf6, 0x15, 0xc1, 0x1d, 0x9d, 0x4d, 0xf4, 0xe5, 0xac, 0x60, 0xf4,
	0x56, 0x3e, 0xff, 0xb0, 0xe9, 0x7d, 0xf9, 0x61, 0xd3, 0xfb, 0xfa, 0xc3, 0xa6, 0xf7, 0xcf, 0x6f,
	0x36, 0x2b, 0xc7, 0x4d, 0x91, 0xe4, 0xee, 0xf7, 0x01, 0x00, 0x00, 0xff, 0xff, 0x31, 0x3c, 0x88,
	0xb0, 0x7f, 0x15, 0x00, 0x00,
}

func (m *Stmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stmt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stmt != nil {
		nn1, err1 := m.Stmt.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Stmt_ShowDatabases) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowDatabases != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowDatabases.Size()))
		n2, err2 := m.ShowDatabases.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}
func (m *Stmt_ShowStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowStats.Size()))
		n3, err3 := m.ShowStats.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}
func (m *Stmt_ShowMetric) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowMetric != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowMetric.Size()))
		n4, err4 := m.ShowMetric.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}
func (m *Stmt_ShowFieldKeys) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowFieldKeys != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowFieldKeys.Size()))
		n5, err5 := m.ShowFieldKeys.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func (m *Stmt_ShowTagKeys) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowTagKeys != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowTagKeys.Size()))
		n6, err6 := m.ShowTagKeys.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}
func (m *Stmt_ShowTagValues) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowTagValues != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowTagValues.Size()))
		n7, err7 := m.ShowTagValues.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}
func (m *Stmt_ShowQueries) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowQueries != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowQueries.Size()))
		n8, err8 := m.ShowQueries.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}
func (m *Stmt_KillQuery) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KillQuery != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.KillQuery.Size()))
		n9, err9 := m.KillQuery.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	return i, nil
}
func (m *Stmt_Query) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Query != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Query.Size()))
		n10, err10 := m.Query.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}
func (m *Stmt_ShowNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowNode != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowNode.Size()))
		n11, err11 := m.ShowNode.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}
func (m *Stmt_DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DropDatabase != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.DropDatabase.Size()))
		n12, err12 := m.DropDatabase.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}
func (m *Stmt_ShowInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowInfo != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowInfo.Size()))
		n13, err13 := m.ShowInfo.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	return i, nil
}
func (m *Stmt_ShowTagValuesInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowTagValuesInfo != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowTagValuesInfo.Size()))
		n14, err14 := m.ShowTagValuesInfo.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	return i, nil
}
func (m *ResultSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		nn15, err15 := m.Result.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += nn15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResultSet_ShowDatabases) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowDatabases != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowDatabases.Size()))
		n16, err16 := m.ShowDatabases.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	return i, nil
}
func (m *ResultSet_ShowStats) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowStats.Size()))
		n17, err17 := m.ShowStats.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	return i, nil
}
func (m *ResultSet_ShowMetric) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowMetric != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowMetric.Size()))
		n18, err18 := m.ShowMetric.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	return i, nil
}
func (m *ResultSet_ShowTagKeys) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowTagKeys != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowTagKeys.Size()))
		n19, err19 := m.ShowTagKeys.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	return i, nil
}
func (m *ResultSet_ShowTagValues) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowTagValues != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowTagValues.Size()))
		n20, err20 := m.ShowTagValues.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	return i, nil
}
func (m *ResultSet_ShowFieldKeys) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowFieldKeys != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowFieldKeys.Size()))
		n21, err21 := m.ShowFieldKeys.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	return i, nil
}
func (m *ResultSet_Query) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Query != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Query.Size()))
		n22, err22 := m.Query.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	return i, nil
}
func (m *ResultSet_ShowNode) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowNode != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowNode.Size()))
		n23, err23 := m.ShowNode.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	return i, nil
}
func (m *ResultSet_ShowInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowInfo.Size()))
		n24, err24 := m.ShowInfo.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	return i, nil
}
func (m *ResultSet_ShowTagValuesInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ShowTagValuesInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ShowTagValuesInfo.Size()))
		n25, err25 := m.ShowTagValuesInfo.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	return i, nil
}
func (m *DropDatabase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropDatabase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Database) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Database)))
		i += copy(dAtA[i:], m.Database)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowDatabases) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDatabases) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowNodeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowNodeResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowDatabasesResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDatabasesResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Database) > 0 {
		for _, s := range m.Database {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Module) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Module)))
		i += copy(dAtA[i:], m.Module)
	}
	if len(m.Component) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowStatsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowStatsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatabaseStates) > 0 {
		for _, msg := range m.DatabaseStates {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStatement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ShardForNodeState) > 0 {
		for _, msg := range m.ShardForNodeState {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintStatement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowMetricResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowMetricResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowFieldKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowFieldKeys) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowFieldKeysResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowFieldKeysResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.Fields) > 0 {
		for k, _ := range m.Fields {
			dAtA[i] = 0x12
			i++
			v := m.Fields[k]
			mapSize := 1 + len(k) + sovStatement(uint64(len(k))) + 1 + len(v) + sovStatement(uint64(len(v)))
			i = encodeVarintStatement(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowInfoResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x1a
			i++
			v := m.Info[k]
			mapSize := 1 + len(k) + sovStatement(uint64(len(k))) + 1 + len(v) + sovStatement(uint64(len(v)))
			i = encodeVarintStatement(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowTagKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowTagKeys) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowTagKeysResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowTagKeysResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.TagKeys) > 0 {
		for _, s := range m.TagKeys {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowTagValues) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowTagValues) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.TagKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.TagKey)))
		i += copy(dAtA[i:], m.TagKey)
	}
	if len(m.TagValue) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.TagValue)))
		i += copy(dAtA[i:], m.TagValue)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Limit))
	}
	if m.Condition != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Condition.Size()))
		n26, err26 := m.Condition.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowTagValuesResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowTagValuesResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowTagValuesInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowTagValuesInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.TagKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.TagKey)))
		i += copy(dAtA[i:], m.TagKey)
	}
	if len(m.TagValue) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.TagValue)))
		i += copy(dAtA[i:], m.TagValue)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowTagValuesInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowTagValuesInfoResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if len(m.TagKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.TagKey)))
		i += copy(dAtA[i:], m.TagKey)
	}
	if len(m.TagValue) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.TagValue)))
		i += copy(dAtA[i:], m.TagValue)
	}
	if len(m.Node) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Node)))
		i += copy(dAtA[i:], m.Node)
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x2a
			i++
			v := m.Info[k]
			mapSize := 1 + len(k) + sovStatement(uint64(len(k))) + 1 + len(v) + sovStatement(uint64(len(v)))
			i = encodeVarintStatement(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowQueries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowQueries) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KillQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KillQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.QueryId))
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.ServerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Query) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Query) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Measurement) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Measurement)))
		i += copy(dAtA[i:], m.Measurement)
	}
	if m.TimeRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.TimeRange.Size()))
		n27, err27 := m.TimeRange.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	if m.Interval != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Interval))
	}
	if len(m.FieldExprList) > 0 {
		for _, msg := range m.FieldExprList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStatement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConditionAggregators) > 0 {
		for _, msg := range m.ConditionAggregators {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintStatement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Condition != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Condition.Size()))
		n28, err28 := m.Condition.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if m.OrderBy != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.OrderBy.Size()))
		n29, err29 := m.OrderBy.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.GroupByExpr != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.GroupByExpr.Size()))
		n30, err30 := m.GroupByExpr.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.Limit != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Limit))
	}
	if len(m.IntervalBy) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.IntervalBy)))
		i += copy(dAtA[i:], m.IntervalBy)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConditionAggregator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionAggregator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Condition != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Condition.Size()))
		n31, err31 := m.Condition.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.UnitId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.UnitId))
	}
	if len(m.Field) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Field)))
		i += copy(dAtA[i:], m.Field)
	}
	if len(m.DownSampling) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.DownSampling)))
		i += copy(dAtA[i:], m.DownSampling)
	}
	if len(m.Aggregator) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Aggregator)))
		i += copy(dAtA[i:], m.Aggregator)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GroupByExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupByExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.HavingClause != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.HavingClause.Size()))
		n32, err32 := m.HavingClause.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueryResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, b := range m.Series {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatement(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ExplainData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.ExplainData)))
		i += copy(dAtA[i:], m.ExplainData)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FieldExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Expr.Size()))
		n33, err33 := m.Expr.MarshalTo(dAtA[i:])
		if err33 != nil {
			return 0, err33
		}
		i += n33
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderByExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderByExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Expr.Size()))
		n34, err34 := m.Expr.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	if m.Desc {
		dAtA[i] = 0x10
		i++
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BoolExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BoolExpr != nil {
		nn35, err35 := m.BoolExpr.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += nn35
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BoolExpr_Binary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Binary != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Binary.Size()))
		n36, err36 := m.Binary.MarshalTo(dAtA[i:])
		if err36 != nil {
			return 0, err36
		}
		i += n36
	}
	return i, nil
}
func (m *BoolExpr_LogicJoinExpr) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogicJoinExpr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.LogicJoinExpr.Size()))
		n37, err37 := m.LogicJoinExpr.MarshalTo(dAtA[i:])
		if err37 != nil {
			return 0, err37
		}
		i += n37
	}
	return i, nil
}
func (m *LogicJoinExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicJoinExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeftBoolExpr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.LeftBoolExpr.Size()))
		n38, err38 := m.LeftBoolExpr.MarshalTo(dAtA[i:])
		if err38 != nil {
			return 0, err38
		}
		i += n38
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Op))
	}
	if m.RightBoolExpr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.RightBoolExpr.Size()))
		n39, err39 := m.RightBoolExpr.MarshalTo(dAtA[i:])
		if err39 != nil {
			return 0, err39
		}
		i += n39
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		nn40, err40 := m.Expr.MarshalTo(dAtA[i:])
		if err40 != nil {
			return 0, err40
		}
		i += nn40
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Expr_Call) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Call != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Call.Size()))
		n41, err41 := m.Call.MarshalTo(dAtA[i:])
		if err41 != nil {
			return 0, err41
		}
		i += n41
	}
	return i, nil
}
func (m *Expr_Ref) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Ref != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Ref.Size()))
		n42, err42 := m.Ref.MarshalTo(dAtA[i:])
		if err42 != nil {
			return 0, err42
		}
		i += n42
	}
	return i, nil
}
func (m *Expr_Binary) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Binary != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Binary.Size()))
		n43, err43 := m.Binary.MarshalTo(dAtA[i:])
		if err43 != nil {
			return 0, err43
		}
		i += n43
	}
	return i, nil
}
func (m *Expr_LongVal) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LongVal != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.LongVal.Size()))
		n44, err44 := m.LongVal.MarshalTo(dAtA[i:])
		if err44 != nil {
			return 0, err44
		}
		i += n44
	}
	return i, nil
}
func (m *Expr_DoubleVal) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DoubleVal != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.DoubleVal.Size()))
		n45, err45 := m.DoubleVal.MarshalTo(dAtA[i:])
		if err45 != nil {
			return 0, err45
		}
		i += n45
	}
	return i, nil
}
func (m *Expr_Condition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Condition != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Condition.Size()))
		n46, err46 := m.Condition.MarshalTo(dAtA[i:])
		if err46 != nil {
			return 0, err46
		}
		i += n46
	}
	return i, nil
}
func (m *CallExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Args) > 0 {
		for _, msg := range m.Args {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LongExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LongExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DoubleExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BinaryExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinaryExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Left != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Left.Size()))
		n47, err47 := m.Left.MarshalTo(dAtA[i:])
		if err47 != nil {
			return 0, err47
		}
		i += n47
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Op))
	}
	if m.Right != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Right.Size()))
		n48, err48 := m.Right.MarshalTo(dAtA[i:])
		if err48 != nil {
			return 0, err48
		}
		i += n48
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValRefExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValRefExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.RefName)))
		i += copy(dAtA[i:], m.RefName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Series) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Series) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.BaseTime))
	}
	if m.Interval != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Interval))
	}
	if m.Start != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.End))
	}
	if m.Group != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.Group.Size()))
		n49, err49 := m.Group.MarshalTo(dAtA[i:])
		if err49 != nil {
			return 0, err49
		}
		i += n49
	}
	if len(m.Aggregators) > 0 {
		for _, msg := range m.Aggregators {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStatement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Fields) > 0 {
		for k, _ := range m.Fields {
			dAtA[i] = 0x3a
			i++
			v := m.Fields[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovStatement(uint64(len(v)))
			}
			mapSize := 1 + sovStatement(uint64(k)) + byteSize
			i = encodeVarintStatement(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatement(dAtA, i, uint64(k))
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintStatement(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if m.GroupValue != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GroupValue))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Aggregator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UnitId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatement(dAtA, i, uint64(m.UnitId))
	}
	if len(m.Fun) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.Fun)))
		i += copy(dAtA[i:], m.Fun)
	}
	if len(m.FieldType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatement(dAtA, i, uint64(len(m.FieldType)))
		i += copy(dAtA[i:], m.FieldType)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintStatement(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Stmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stmt != nil {
		n += m.Stmt.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stmt_ShowDatabases) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowDatabases != nil {
		l = m.ShowDatabases.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowStats != nil {
		l = m.ShowStats.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowMetric != nil {
		l = m.ShowMetric.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowFieldKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowFieldKeys != nil {
		l = m.ShowFieldKeys.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowTagKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowTagKeys != nil {
		l = m.ShowTagKeys.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowTagValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowTagValues != nil {
		l = m.ShowTagValues.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowQueries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowQueries != nil {
		l = m.ShowQueries.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_KillQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KillQuery != nil {
		l = m.KillQuery.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowNode != nil {
		l = m.ShowNode.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_DropDatabase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropDatabase != nil {
		l = m.DropDatabase.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowInfo != nil {
		l = m.ShowInfo.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Stmt_ShowTagValuesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowTagValuesInfo != nil {
		l = m.ShowTagValuesInfo.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultSet_ShowDatabases) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowDatabases != nil {
		l = m.ShowDatabases.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowStats != nil {
		l = m.ShowStats.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowMetric != nil {
		l = m.ShowMetric.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowTagKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowTagKeys != nil {
		l = m.ShowTagKeys.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowTagValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowTagValues != nil {
		l = m.ShowTagValues.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowFieldKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowFieldKeys != nil {
		l = m.ShowFieldKeys.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowNode != nil {
		l = m.ShowNode.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowInfo != nil {
		l = m.ShowInfo.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *ResultSet_ShowTagValuesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShowTagValuesInfo != nil {
		l = m.ShowTagValuesInfo.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *DropDatabase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowDatabases) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowNodeResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowDatabasesResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Database) > 0 {
		for _, s := range m.Database {
			l = len(s)
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowStatsResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DatabaseStates) > 0 {
		for _, e := range m.DatabaseStates {
			l = e.Size()
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if len(m.ShardForNodeState) > 0 {
		for _, e := range m.ShardForNodeState {
			l = e.Size()
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovStatement(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowMetricResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			l = len(s)
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowFieldKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovStatement(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowFieldKeysResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatement(uint64(len(k))) + 1 + len(v) + sovStatement(uint64(len(v)))
			n += mapEntrySize + 1 + sovStatement(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowInfoResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatement(uint64(len(k))) + 1 + len(v) + sovStatement(uint64(len(v)))
			n += mapEntrySize + 1 + sovStatement(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowTagKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovStatement(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowTagKeysResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.TagKeys) > 0 {
		for _, s := range m.TagKeys {
			l = len(s)
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowTagValues) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.TagKey)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.TagValue)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovStatement(uint64(m.Limit))
	}
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowTagValuesResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowTagValuesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.TagKey)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.TagValue)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowTagValuesInfoResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.TagKey)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.TagValue)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatement(uint64(len(k))) + 1 + len(v) + sovStatement(uint64(len(v)))
			n += mapEntrySize + 1 + sovStatement(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowQueries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KillQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryId != 0 {
		n += 1 + sovStatement(uint64(m.QueryId))
	}
	if m.ServerId != 0 {
		n += 1 + sovStatement(uint64(m.ServerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Query) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Measurement)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovStatement(uint64(m.Interval))
	}
	if len(m.FieldExprList) > 0 {
		for _, e := range m.FieldExprList {
			l = e.Size()
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if len(m.ConditionAggregators) > 0 {
		for _, e := range m.ConditionAggregators {
			l = e.Size()
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.OrderBy != nil {
		l = m.OrderBy.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.GroupByExpr != nil {
		l = m.GroupByExpr.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovStatement(uint64(m.Limit))
	}
	l = len(m.IntervalBy)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConditionAggregator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.UnitId != 0 {
		n += 1 + sovStatement(uint64(m.UnitId))
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.DownSampling)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.Aggregator)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupByExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupBy) > 0 {
		for _, s := range m.GroupBy {
			l = len(s)
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.HavingClause != nil {
		l = m.HavingClause.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, b := range m.Series {
			l = len(b)
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	l = len(m.ExplainData)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderByExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Desc {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoolExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoolExpr != nil {
		n += m.BoolExpr.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoolExpr_Binary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binary != nil {
		l = m.Binary.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *BoolExpr_LogicJoinExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogicJoinExpr != nil {
		l = m.LogicJoinExpr.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *LogicJoinExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftBoolExpr != nil {
		l = m.LeftBoolExpr.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovStatement(uint64(m.Op))
	}
	if m.RightBoolExpr != nil {
		l = m.RightBoolExpr.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expr != nil {
		n += m.Expr.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Expr_Call) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Call != nil {
		l = m.Call.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Expr_Ref) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ref != nil {
		l = m.Ref.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Expr_Binary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binary != nil {
		l = m.Binary.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Expr_LongVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LongVal != nil {
		l = m.LongVal.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Expr_DoubleVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DoubleVal != nil {
		l = m.DoubleVal.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *Expr_Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	return n
}
func (m *CallExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LongExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovStatement(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DoubleExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BinaryExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovStatement(uint64(m.Op))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValRefExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefName)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Series) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseTime != 0 {
		n += 1 + sovStatement(uint64(m.BaseTime))
	}
	if m.Interval != 0 {
		n += 1 + sovStatement(uint64(m.Interval))
	}
	if m.Start != 0 {
		n += 1 + sovStatement(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovStatement(uint64(m.End))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovStatement(uint64(l))
	}
	if len(m.Aggregators) > 0 {
		for _, e := range m.Aggregators {
			l = e.Size()
			n += 1 + l + sovStatement(uint64(l))
		}
	}
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovStatement(uint64(len(v)))
			}
			mapEntrySize := 1 + sovStatement(uint64(k)) + l
			n += mapEntrySize + 1 + sovStatement(uint64(mapEntrySize))
		}
	}
	if m.GroupValue != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitId != 0 {
		n += 1 + sovStatement(uint64(m.UnitId))
	}
	l = len(m.Fun)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	l = len(m.FieldType)
	if l > 0 {
		n += 1 + l + sovStatement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStatement(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStatement(x uint64) (n int) {
	return sovStatement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Stmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowDatabases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowDatabases{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowDatabases{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowStats{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowStats{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowMetric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowMetric{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowFieldKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowFieldKeys{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowFieldKeys{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTagKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowTagKeys{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowTagKeys{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTagValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowTagValues{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowTagValues{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowQueries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowQueries{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KillQuery{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_KillQuery{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Query{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_Query{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowNode{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DropDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_DropDatabase{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowInfo{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTagValuesInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowTagValuesInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Stmt = &Stmt_ShowTagValuesInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowDatabases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowDatabasesResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowDatabases{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowStatsResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowStats{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowMetric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowMetricResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowMetric{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTagKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowTagKeysResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowTagKeys{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTagValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowTagValuesResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowTagValues{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowFieldKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowFieldKeysResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowFieldKeys{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_Query{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowNodeResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowNode{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowInfoResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowInfo{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTagValuesInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ShowTagValuesInfoResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &ResultSet_ShowTagValuesInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDatabases) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDatabases: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDatabases: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowNodeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowNodeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowNodeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDatabasesResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDatabasesResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDatabasesResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = append(m.Database, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowStatsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowStatsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowStatsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseStates = append(m.DatabaseStates, &DatabaseState{})
			if err := m.DatabaseStates[len(m.DatabaseStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardForNodeState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardForNodeState = append(m.ShardForNodeState, &ShardForNode{})
			if err := m.ShardForNodeState[len(m.ShardForNodeState)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowMetricResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowMetricResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowMetricResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowFieldKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowFieldKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowFieldKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowFieldKeysResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowFieldKeysResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowFieldKeysResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatement
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatement
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatement
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatement
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStatement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatement
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatement
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatement
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatement
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStatement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowTagKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowTagKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowTagKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowTagKeysResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowTagKeysResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowTagKeysResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagKeys = append(m.TagKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowTagValues) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowTagValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowTagValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Condition{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowTagValuesResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowTagValuesResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowTagValuesResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowTagValuesInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowTagValuesInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowTagValuesInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowTagValuesInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowTagValuesInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowTagValuesInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatement
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatement
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatement
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatement
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStatement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowQueries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowQueries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowQueries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KillQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KillQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KillQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			m.QueryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Query) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Query: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Query: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Measurement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Measurement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRange == nil {
				m.TimeRange = &TimeRange{}
			}
			if err := m.TimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldExprList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldExprList = append(m.FieldExprList, &FieldExpr{})
			if err := m.FieldExprList[len(m.FieldExprList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionAggregators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionAggregators = append(m.ConditionAggregators, &ConditionAggregator{})
			if err := m.ConditionAggregators[len(m.ConditionAggregators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Condition{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderBy == nil {
				m.OrderBy = &OrderByExpr{}
			}
			if err := m.OrderBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupByExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupByExpr == nil {
				m.GroupByExpr = &GroupByExpr{}
			}
			if err := m.GroupByExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntervalBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionAggregator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionAggregator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionAggregator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Condition{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitId", wireType)
			}
			m.UnitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSampling", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownSampling = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupByExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupByExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupByExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = append(m.GroupBy, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HavingClause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HavingClause == nil {
				m.HavingClause = &BoolExpr{}
			}
			if err := m.HavingClause.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, make([]byte, postIndex-iNdEx))
			copy(m.Series[len(m.Series)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplainData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExplainData = append(m.ExplainData[:0], dAtA[iNdEx:postIndex]...)
			if m.ExplainData == nil {
				m.ExplainData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderByExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderByExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderByExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BinaryExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BoolExpr = &BoolExpr_Binary{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicJoinExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicJoinExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BoolExpr = &BoolExpr_LogicJoinExpr{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicJoinExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicJoinExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicJoinExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftBoolExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftBoolExpr == nil {
				m.LeftBoolExpr = &BoolExpr{}
			}
			if err := m.LeftBoolExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= LogicOperator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightBoolExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightBoolExpr == nil {
				m.RightBoolExpr = &BoolExpr{}
			}
			if err := m.RightBoolExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Call", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CallExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Call{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ValRefExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Ref{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BinaryExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Binary{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LongExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_LongVal{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DoubleExpr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_DoubleVal{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Condition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expr = &Expr_Condition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &Expr{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LongExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LongExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LongExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &Expr{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Operator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &Expr{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValRefExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValRefExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValRefExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Series) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Series: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Series: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseTime", wireType)
			}
			m.BaseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Tag{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregators = append(m.Aggregators, &Aggregator{})
			if err := m.Aggregators[len(m.Aggregators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[int32][]byte)
			}
			var mapkey int32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthStatement
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthStatement
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthStatement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GroupValue = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitId", wireType)
			}
			m.UnitId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fun", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fun = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStatement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStatement
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthStatement
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStatement
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStatement(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthStatement
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStatement = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatement   = fmt.Errorf("proto: integer overflow")
)
